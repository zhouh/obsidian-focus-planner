/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FocusPlannerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/types.ts
var EventCategory = /* @__PURE__ */ ((EventCategory3) => {
  EventCategory3["FOCUS"] = "focus";
  EventCategory3["MEETING"] = "meeting";
  EventCategory3["PERSONAL"] = "personal";
  EventCategory3["REST"] = "rest";
  EventCategory3["ADMIN"] = "admin";
  return EventCategory3;
})(EventCategory || {});
var CATEGORY_COLORS = {
  ["focus" /* FOCUS */]: "#22c55e",
  // Green
  ["meeting" /* MEETING */]: "#3b82f6",
  // Blue
  ["personal" /* PERSONAL */]: "#f97316",
  // Orange
  ["rest" /* REST */]: "#6b7280",
  // Gray
  ["admin" /* ADMIN */]: "#eab308"
  // Yellow
};
var CATEGORY_LABELS = {
  ["focus" /* FOCUS */]: "\u4E13\u6CE8\u5B66\u4E60",
  ["meeting" /* MEETING */]: "\u4F1A\u8BAE",
  ["personal" /* PERSONAL */]: "\u5BB6\u5EAD/\u4E2A\u4EBA",
  ["rest" /* REST */]: "\u4F11\u606F",
  ["admin" /* ADMIN */]: "\u4E8B\u52A1"
};
var DEFAULT_SETTINGS = {
  feishu: {
    appId: "",
    appSecret: "",
    syncEnabled: false,
    syncInterval: 15,
    useCalDav: false
  },
  dailyNotePath: "0. PeriodicNotes/YYYY/Daily/MM/YYYY-MM-DD.md",
  weeklyNotePath: "0. PeriodicNotes/YYYY/Weekly/YYYY-WXX.md",
  pomodoroMinutes: 25,
  categoryKeywords: {
    ["focus" /* FOCUS */]: ["\u4E13\u6CE8", "\u5B66\u4E60", "\u9605\u8BFB", "\u4EE3\u7801", "demo", "\u8BBA\u6587", "coding", "study"],
    ["meeting" /* MEETING */]: ["\u4F1A\u8BAE", "\u8BA8\u8BBA", "\u5468\u4F1A", "Seminar", "oneone", "sync", "meeting"],
    ["personal" /* PERSONAL */]: ["\u5BB6\u5EAD", "\u4E2A\u4EBA", "\u665A\u95F4", "gym", "personal", "family"],
    ["rest" /* REST */]: ["\u5348\u4F11", "\u4F11\u606F", "break", "lunch"],
    ["admin" /* ADMIN */]: ["\u62A5\u9500", "\u884C\u653F", "Review", "admin"]
  },
  showStatsPanel: true
};

// src/feishuApi.ts
var import_obsidian = require("obsidian");
var FEISHU_API_BASE = "https://open.feishu.cn/open-apis";
var FeishuApi = class {
  constructor(settings, onSettingsChange) {
    this.settings = settings;
    this.onSettingsChange = onSettingsChange;
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  // Get tenant access token (app-level token)
  async getTenantAccessToken() {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${FEISHU_API_BASE}/auth/v3/tenant_access_token/internal`,
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        app_id: this.settings.appId,
        app_secret: this.settings.appSecret
      })
    });
    if (response.json.code !== 0) {
      throw new Error(`Failed to get tenant access token: ${response.json.msg}`);
    }
    return response.json.tenant_access_token;
  }
  // Get user access token via OAuth
  async getUserAccessToken(code) {
    const tenantToken = await this.getTenantAccessToken();
    const response = await (0, import_obsidian.requestUrl)({
      url: `${FEISHU_API_BASE}/authen/v1/oidc/access_token`,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${tenantToken}`
      },
      body: JSON.stringify({
        grant_type: "authorization_code",
        code
      })
    });
    if (response.json.code !== 0) {
      throw new Error(`Failed to get user access token: ${response.json.msg}`);
    }
    const data = response.json.data;
    return {
      accessToken: data.access_token,
      refreshToken: data.refresh_token,
      expiresIn: data.expires_in
    };
  }
  // Refresh access token
  async refreshAccessToken() {
    if (!this.settings.refreshToken) {
      throw new Error("No refresh token available");
    }
    const tenantToken = await this.getTenantAccessToken();
    const response = await (0, import_obsidian.requestUrl)({
      url: `${FEISHU_API_BASE}/authen/v1/oidc/refresh_access_token`,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${tenantToken}`
      },
      body: JSON.stringify({
        grant_type: "refresh_token",
        refresh_token: this.settings.refreshToken
      })
    });
    if (response.json.code !== 0) {
      throw new Error(`Failed to refresh token: ${response.json.msg}`);
    }
    const data = response.json.data;
    this.settings.accessToken = data.access_token;
    this.settings.refreshToken = data.refresh_token;
    this.settings.tokenExpiry = Date.now() + data.expires_in * 1e3;
    this.onSettingsChange(this.settings);
  }
  // Ensure we have a valid access token
  async ensureValidToken() {
    if (!this.settings.accessToken) {
      throw new Error("Not authenticated. Please login first.");
    }
    if (this.settings.tokenExpiry && Date.now() > this.settings.tokenExpiry - 3e5) {
      await this.refreshAccessToken();
    }
    return this.settings.accessToken;
  }
  // Get all readable calendar IDs (all primary calendars named "Âë®Êµ©")
  async getAllCalendarIds() {
    var _a, _b, _c;
    const token = await this.ensureValidToken();
    console.log("[Focus Planner] Getting calendar list...");
    let response;
    try {
      response = await (0, import_obsidian.requestUrl)({
        url: `${FEISHU_API_BASE}/calendar/v4/calendars?page_size=50`,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${token}`,
          "Content-Type": "application/json; charset=utf-8"
        },
        throw: false
      });
    } catch (e) {
      console.error("[Focus Planner] Calendar list request exception:", e);
      throw new Error(`\u83B7\u53D6\u65E5\u5386\u5217\u8868\u5931\u8D25: ${e.message}`);
    }
    console.log("[Focus Planner] Calendar list response:", response.status, response.json);
    if (response.status !== 200) {
      const errorMsg = ((_a = response.json) == null ? void 0 : _a.msg) || ((_b = response.json) == null ? void 0 : _b.message) || `HTTP ${response.status}`;
      throw new Error(`\u83B7\u53D6\u65E5\u5386\u5217\u8868\u5931\u8D25 (${response.status}): ${errorMsg}`);
    }
    if (response.json.code !== 0) {
      throw new Error(`Failed to get calendar list: ${response.json.msg} (code: ${response.json.code})`);
    }
    const calendars = ((_c = response.json.data) == null ? void 0 : _c.calendar_list) || [];
    console.log("[Focus Planner] Found calendars:", calendars.length);
    for (const cal of calendars) {
      console.log("[Focus Planner] Calendar:", {
        id: cal.calendar_id,
        summary: cal.summary,
        type: cal.type,
        role: cal.role,
        is_primary: cal.is_primary
      });
    }
    const calendarIds = [];
    for (const cal of calendars) {
      if (cal.role === "owner" || cal.role === "writer") {
        calendarIds.push(cal.calendar_id);
        console.log("[Focus Planner] Added calendar:", cal.calendar_id, cal.summary, "role:", cal.role);
      } else {
        console.log("[Focus Planner] Skipping calendar (no write access):", cal.calendar_id, cal.summary, "role:", cal.role);
      }
    }
    if (calendarIds.length === 0) {
      throw new Error("\u672A\u627E\u5230\u53EF\u7528\u7684\u65E5\u5386\uFF0C\u8BF7\u786E\u4FDD\u98DE\u4E66\u8D26\u53F7\u6709\u65E5\u5386\u6743\u9650");
    }
    console.log("[Focus Planner] Total calendars to sync:", calendarIds.length);
    return calendarIds;
  }
  // Get calendar events (from all primary calendars)
  // Ëé∑ÂèñÊâÄÊúâ‰∫ã‰ª∂ÔºåÁÑ∂ÂêéÂú®ÂÆ¢Êà∑Á´ØËøáÊª§ÂíåÂ±ïÂºÄÈáçÂ§çÊó•Á®ã
  async getEvents(startTime, endTime) {
    const token = await this.ensureValidToken();
    const calendarIds = await this.getAllCalendarIds();
    console.log(
      "[Focus Planner] Fetching events from",
      calendarIds.length,
      "calendars for range:",
      startTime.toISOString(),
      "to",
      endTime.toISOString()
    );
    const allEvents = [];
    const seenEventIds = /* @__PURE__ */ new Set();
    for (const calendarId of calendarIds) {
      try {
        const events = await this.getEventsFromCalendar(calendarId, token, startTime, endTime);
        for (const event of events) {
          const eventKey = `${event.title}-${event.start.getTime()}`;
          if (!seenEventIds.has(eventKey)) {
            seenEventIds.add(eventKey);
            allEvents.push(event);
          } else {
            console.log("[Focus Planner] Skipping duplicate event:", event.title);
          }
        }
      } catch (e) {
        console.error("[Focus Planner] Failed to fetch from calendar", calendarId, ":", e.message);
      }
    }
    console.log("[Focus Planner] Total unique events for this week:", allEvents.length);
    return allEvents;
  }
  // Get events from a single calendar
  async getEventsFromCalendar(calendarId, token, queryStart, queryEnd) {
    var _a, _b, _c, _d;
    const encodedCalendarId = encodeURIComponent(calendarId);
    const url = `${FEISHU_API_BASE}/calendar/v4/calendars/${encodedCalendarId}/events?page_size=500`;
    console.log("[Focus Planner] Fetching from calendar:", calendarId);
    let response;
    try {
      response = await (0, import_obsidian.requestUrl)({
        url,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${token}`,
          "Content-Type": "application/json; charset=utf-8"
        },
        throw: false
      });
    } catch (e) {
      console.error("[Focus Planner] Request exception:", e);
      throw new Error(`\u7F51\u7EDC\u8BF7\u6C42\u5931\u8D25: ${e.message}`);
    }
    console.log("[Focus Planner] Response status:", response.status, "from calendar:", calendarId);
    if (response.status !== 200) {
      const errorMsg = ((_a = response.json) == null ? void 0 : _a.msg) || ((_b = response.json) == null ? void 0 : _b.message) || `HTTP ${response.status}`;
      const errorCode = (_c = response.json) == null ? void 0 : _c.code;
      console.error("[Focus Planner] API error from calendar", calendarId, ":", errorCode, errorMsg);
      throw new Error(`API \u8BF7\u6C42\u5931\u8D25 (${errorCode || response.status}): ${errorMsg}`);
    }
    if (response.json.code !== 0) {
      console.error("[Focus Planner] API error code from calendar", calendarId, ":", response.json.code, response.json.msg);
      throw new Error(`Failed to get events: ${response.json.msg} (code: ${response.json.code})`);
    }
    const rawItems = ((_d = response.json.data) == null ? void 0 : _d.items) || [];
    console.log("[Focus Planner] Raw events from calendar", calendarId, ":", rawItems.length);
    const events = [];
    for (const item of rawItems) {
      if (item.status === "cancelled") {
        continue;
      }
      const parsedEvents = this.parseFeishuEvent(item, queryStart, queryEnd);
      for (const event of parsedEvents) {
        events.push(event);
      }
    }
    console.log("[Focus Planner] Events from calendar", calendarId, ":", events.length);
    return events;
  }
  // Parse Feishu event to our CalendarEvent format
  // Â§ÑÁêÜÈáçÂ§çÊó•Á®ãÔºåËøîÂõûÂú®Êü•ËØ¢ËåÉÂõ¥ÂÜÖÁöÑÊâÄÊúâÂÆû‰æã
  parseFeishuEvent(feishuEvent, queryStart, queryEnd) {
    try {
      const startTime = feishuEvent.start_time;
      const endTime = feishuEvent.end_time;
      const recurrence = feishuEvent.recurrence;
      let eventStart;
      let eventEnd;
      let isAllDay = false;
      if ((startTime == null ? void 0 : startTime.date) && !(startTime == null ? void 0 : startTime.timestamp)) {
        isAllDay = true;
        eventStart = new Date(startTime.date + "T09:00:00");
        eventEnd = new Date(((endTime == null ? void 0 : endTime.date) || startTime.date) + "T18:00:00");
      } else if ((startTime == null ? void 0 : startTime.timestamp) && (endTime == null ? void 0 : endTime.timestamp)) {
        eventStart = new Date(parseInt(startTime.timestamp) * 1e3);
        eventEnd = new Date(parseInt(endTime.timestamp) * 1e3);
      } else {
        console.log("[Focus Planner] Cannot parse time for event:", feishuEvent.summary);
        return [];
      }
      const duration = eventEnd.getTime() - eventStart.getTime();
      const title = feishuEvent.summary || "Untitled Event";
      const category = this.categorizeEvent(title);
      if (!recurrence) {
        if (eventEnd >= queryStart && eventStart <= queryEnd) {
          return [{
            id: `feishu-${feishuEvent.event_id}`,
            title,
            start: eventStart,
            end: eventEnd,
            category,
            source: "feishu",
            feishuEventId: feishuEvent.event_id
          }];
        }
        return [];
      }
      const instances = this.expandRecurrence(eventStart, duration, recurrence, queryStart, queryEnd);
      return instances.map((instanceStart, index) => ({
        id: `feishu-${feishuEvent.event_id}-${index}`,
        title,
        start: instanceStart,
        end: new Date(instanceStart.getTime() + duration),
        category,
        source: "feishu",
        feishuEventId: feishuEvent.event_id
      }));
    } catch (e) {
      console.error("Failed to parse Feishu event:", e, feishuEvent);
      return [];
    }
  }
  // Â±ïÂºÄÈáçÂ§çËßÑÂàôÔºåËøîÂõûÂú®Êü•ËØ¢ËåÉÂõ¥ÂÜÖÁöÑÊâÄÊúâÂÆû‰æãÂºÄÂßãÊó∂Èó¥
  expandRecurrence(eventStart, duration, rrule, queryStart, queryEnd) {
    var _a;
    const instances = [];
    const rules = {};
    for (const part of rrule.split(";")) {
      const [key, value] = part.split("=");
      if (key && value) {
        rules[key] = value;
      }
    }
    const freq = rules["FREQ"];
    const interval = parseInt(rules["INTERVAL"] || "1");
    const until = rules["UNTIL"] ? this.parseRRuleDate(rules["UNTIL"]) : null;
    const count = rules["COUNT"] ? parseInt(rules["COUNT"]) : null;
    const byDay = ((_a = rules["BYDAY"]) == null ? void 0 : _a.split(",")) || [];
    let repeatEnd = queryEnd;
    if (until && until < repeatEnd) {
      repeatEnd = until;
    }
    let current = new Date(eventStart);
    let instanceCount = 0;
    const maxIterations = 1e3;
    for (let i = 0; i < maxIterations && current <= repeatEnd; i++) {
      if (count && instanceCount >= count)
        break;
      const instanceEnd = new Date(current.getTime() + duration);
      if (instanceEnd >= queryStart && current <= queryEnd) {
        if (byDay.length === 0 || this.matchesByDay(current, byDay)) {
          instances.push(new Date(current));
          instanceCount++;
        }
      }
      switch (freq) {
        case "DAILY":
          current.setDate(current.getDate() + interval);
          break;
        case "WEEKLY":
          if (byDay.length > 0) {
            current.setDate(current.getDate() + 1);
          } else {
            current.setDate(current.getDate() + 7 * interval);
          }
          break;
        case "MONTHLY":
          current.setMonth(current.getMonth() + interval);
          break;
        case "YEARLY":
          current.setFullYear(current.getFullYear() + interval);
          break;
        default:
          return [];
      }
    }
    return instances;
  }
  // Ëß£Êûê RRULE Êó•ÊúüÊ†ºÂºè (YYYYMMDD Êàñ YYYYMMDDTHHMMSSZ)
  parseRRuleDate(dateStr) {
    if (dateStr.includes("T")) {
      const year = parseInt(dateStr.substring(0, 4));
      const month = parseInt(dateStr.substring(4, 6)) - 1;
      const day = parseInt(dateStr.substring(6, 8));
      const hour = parseInt(dateStr.substring(9, 11));
      const minute = parseInt(dateStr.substring(11, 13));
      const second = parseInt(dateStr.substring(13, 15));
      return new Date(Date.UTC(year, month, day, hour, minute, second));
    } else {
      const year = parseInt(dateStr.substring(0, 4));
      const month = parseInt(dateStr.substring(4, 6)) - 1;
      const day = parseInt(dateStr.substring(6, 8));
      return new Date(year, month, day);
    }
  }
  // Ê£ÄÊü•Êó•ÊúüÊòØÂê¶ÂåπÈÖç BYDAY ËßÑÂàô
  matchesByDay(date, byDay) {
    const dayMap = {
      0: "SU",
      1: "MO",
      2: "TU",
      3: "WE",
      4: "TH",
      5: "FR",
      6: "SA"
    };
    const dayCode = dayMap[date.getDay()];
    return byDay.some((d) => d.includes(dayCode));
  }
  // Categorize event based on title keywords
  categorizeEvent(title) {
    const lowerTitle = title.toLowerCase();
    const categoryOrder = [
      "rest" /* REST */,
      "meeting" /* MEETING */,
      "personal" /* PERSONAL */,
      "admin" /* ADMIN */,
      "focus" /* FOCUS */
    ];
    const keywords = {
      ["focus" /* FOCUS */]: ["\u4E13\u6CE8", "\u5B66\u4E60", "\u9605\u8BFB", "\u4EE3\u7801", "demo", "\u8BBA\u6587"],
      ["meeting" /* MEETING */]: ["\u4F1A\u8BAE", "\u8BA8\u8BBA", "\u5468\u4F1A", "seminar", "oneone", "sync", "meeting"],
      ["personal" /* PERSONAL */]: ["\u5BB6\u5EAD", "\u4E2A\u4EBA", "\u665A\u95F4"],
      ["rest" /* REST */]: ["\u5348\u4F11", "\u4F11\u606F", "break"],
      ["admin" /* ADMIN */]: ["\u62A5\u9500", "\u884C\u653F", "review"]
    };
    for (const category of categoryOrder) {
      for (const keyword of keywords[category]) {
        if (lowerTitle.includes(keyword.toLowerCase())) {
          return category;
        }
      }
    }
    return "meeting" /* MEETING */;
  }
  // Generate OAuth login URL
  getOAuthUrl(redirectUri) {
    const params = new URLSearchParams({
      app_id: this.settings.appId,
      redirect_uri: redirectUri,
      state: "focus-planner-auth",
      // ËØ∑Ê±ÇÊó•ÂéÜÊùÉÈôê
      scope: "calendar:calendar:readonly calendar:calendar:read"
    });
    return `https://open.feishu.cn/open-apis/authen/v1/authorize?${params.toString()}`;
  }
};

// src/caldavClient.ts
var import_obsidian2 = require("obsidian");
var CALDAV_SERVER = "https://caldav.feishu.cn";
var CalDavClient = class {
  constructor(settings, categoryKeywords) {
    this.settings = settings;
    this.categoryKeywords = categoryKeywords;
  }
  updateSettings(settings, categoryKeywords) {
    this.settings = settings;
    this.categoryKeywords = categoryKeywords;
  }
  // Get events for a date range using CalDAV REPORT
  async getEvents(startTime, endTime) {
    if (!this.settings.caldavUsername || !this.settings.caldavPassword) {
      throw new Error("\u8BF7\u5148\u914D\u7F6E CalDAV \u7528\u6237\u540D\u548C\u5BC6\u7801");
    }
    const auth = btoa(`${this.settings.caldavUsername}:${this.settings.caldavPassword}`);
    const calendarUrl = await this.discoverCalendar(auth);
    if (!calendarUrl) {
      throw new Error("\u672A\u627E\u5230\u65E5\u5386\uFF0C\u8BF7\u68C0\u67E5 CalDAV \u914D\u7F6E");
    }
    console.log("[Focus Planner] CalDAV calendar URL:", calendarUrl);
    const events = await this.fetchEventsFromCalendar(calendarUrl, auth, startTime, endTime);
    console.log("[Focus Planner] CalDAV fetched events:", events.length);
    return events;
  }
  // Discover the user's calendar URL
  async discoverCalendar(auth) {
    const propfindBody = `<?xml version="1.0" encoding="utf-8"?>
<d:propfind xmlns:d="DAV:">
  <d:prop>
    <d:current-user-principal/>
  </d:prop>
</d:propfind>`;
    try {
      const response = await (0, import_obsidian2.requestUrl)({
        url: CALDAV_SERVER,
        method: "PROPFIND",
        headers: {
          "Authorization": `Basic ${auth}`,
          "Content-Type": "application/xml; charset=utf-8",
          "Depth": "0"
        },
        body: propfindBody,
        throw: false
      });
      console.log("[Focus Planner] CalDAV PROPFIND response:", response.status);
      if (response.status === 401) {
        throw new Error("CalDAV \u8BA4\u8BC1\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u7528\u6237\u540D\u548C\u5BC6\u7801");
      }
      if (response.status !== 207) {
        throw new Error(`CalDAV \u8BF7\u6C42\u5931\u8D25: ${response.status}`);
      }
      const principalMatch = response.text.match(/<d:current-user-principal>[\s\S]*?<d:href>([^<]+)<\/d:href>/i);
      if (!principalMatch) {
        console.log("[Focus Planner] CalDAV response:", response.text);
        throw new Error("\u65E0\u6CD5\u83B7\u53D6\u7528\u6237\u4E3B\u4F53 URL");
      }
      const principalUrl = principalMatch[1];
      console.log("[Focus Planner] Principal URL:", principalUrl);
      const calendarHomeUrl = await this.getCalendarHome(principalUrl, auth);
      if (!calendarHomeUrl) {
        throw new Error("\u65E0\u6CD5\u83B7\u53D6\u65E5\u5386\u4E3B\u76EE\u5F55");
      }
      console.log("[Focus Planner] Calendar home URL:", calendarHomeUrl);
      const calendarUrl = await this.getDefaultCalendar(calendarHomeUrl, auth);
      return calendarUrl;
    } catch (e) {
      console.error("[Focus Planner] CalDAV discovery error:", e);
      throw e;
    }
  }
  // Get the calendar home set URL
  async getCalendarHome(principalUrl, auth) {
    const fullUrl = principalUrl.startsWith("http") ? principalUrl : `${CALDAV_SERVER}${principalUrl}`;
    const propfindBody = `<?xml version="1.0" encoding="utf-8"?>
<d:propfind xmlns:d="DAV:" xmlns:c="urn:ietf:params:xml:ns:caldav">
  <d:prop>
    <c:calendar-home-set/>
  </d:prop>
</d:propfind>`;
    const response = await (0, import_obsidian2.requestUrl)({
      url: fullUrl,
      method: "PROPFIND",
      headers: {
        "Authorization": `Basic ${auth}`,
        "Content-Type": "application/xml; charset=utf-8",
        "Depth": "0"
      },
      body: propfindBody,
      throw: false
    });
    if (response.status !== 207) {
      console.error("[Focus Planner] Calendar home PROPFIND failed:", response.status, response.text);
      return null;
    }
    const homeMatch = response.text.match(/<c:calendar-home-set>[\s\S]*?<d:href>([^<]+)<\/d:href>/i) || response.text.match(/<cal:calendar-home-set>[\s\S]*?<d:href>([^<]+)<\/d:href>/i);
    if (!homeMatch) {
      console.log("[Focus Planner] Calendar home response:", response.text);
      return null;
    }
    return homeMatch[1];
  }
  // Get the default calendar URL
  async getDefaultCalendar(homeUrl, auth) {
    const fullUrl = homeUrl.startsWith("http") ? homeUrl : `${CALDAV_SERVER}${homeUrl}`;
    const propfindBody = `<?xml version="1.0" encoding="utf-8"?>
<d:propfind xmlns:d="DAV:" xmlns:c="urn:ietf:params:xml:ns:caldav">
  <d:prop>
    <d:resourcetype/>
    <d:displayname/>
  </d:prop>
</d:propfind>`;
    const response = await (0, import_obsidian2.requestUrl)({
      url: fullUrl,
      method: "PROPFIND",
      headers: {
        "Authorization": `Basic ${auth}`,
        "Content-Type": "application/xml; charset=utf-8",
        "Depth": "1"
      },
      body: propfindBody,
      throw: false
    });
    console.log("[Focus Planner] Calendar list PROPFIND status:", response.status);
    console.log("[Focus Planner] Calendar list response preview:", response.text.substring(0, 1e3));
    if (response.status !== 207) {
      console.error("[Focus Planner] Calendar list PROPFIND failed:", response.status);
      return homeUrl;
    }
    const calendarMatches = response.text.matchAll(/<d:response>[\s\S]*?<d:href>([^<]+)<\/d:href>[\s\S]*?<d:resourcetype>[\s\S]*?(?:<c:calendar|<cal:calendar)[^>]*\/?>/gi);
    const calendars = [];
    for (const match of calendarMatches) {
      const href = match[1];
      if (href !== homeUrl && href.length > homeUrl.length) {
        console.log("[Focus Planner] Found calendar:", href);
        calendars.push(href);
      }
    }
    if (calendars.length > 0) {
      return calendars[0];
    }
    const allHrefs = response.text.matchAll(/<d:href>([^<]+)<\/d:href>/gi);
    for (const match of allHrefs) {
      const href = match[1];
      if (href !== homeUrl && href.startsWith(homeUrl) && href.length > homeUrl.length) {
        console.log("[Focus Planner] Found potential calendar URL:", href);
        return href;
      }
    }
    console.log("[Focus Planner] No sub-calendars found, using home URL as calendar");
    return homeUrl;
  }
  // Fetch events from a calendar
  // Try calendar-query REPORT first, fall back to PROPFIND + individual GET
  async fetchEventsFromCalendar(calendarUrl, auth, startTime, endTime) {
    const fullUrl = calendarUrl.startsWith("http") ? calendarUrl : `${CALDAV_SERVER}${calendarUrl}`;
    const reportEvents = await this.tryCalendarQueryReport(fullUrl, auth, startTime, endTime);
    if (reportEvents !== null) {
      return reportEvents;
    }
    console.log("[Focus Planner] REPORT not supported, falling back to PROPFIND + GET");
    return await this.fetchEventsViaPropfind(fullUrl, auth, startTime, endTime);
  }
  // Try the calendar-query REPORT method (may not be supported by all servers)
  async tryCalendarQueryReport(fullUrl, auth, startTime, endTime) {
    const startStr = this.formatDateForCalDav(startTime);
    const endStr = this.formatDateForCalDav(endTime);
    const reportBody = `<?xml version="1.0" encoding="utf-8"?>
<c:calendar-query xmlns:d="DAV:" xmlns:c="urn:ietf:params:xml:ns:caldav">
  <d:prop>
    <d:getetag/>
    <c:calendar-data/>
  </d:prop>
  <c:filter>
    <c:comp-filter name="VCALENDAR">
      <c:comp-filter name="VEVENT">
        <c:time-range start="${startStr}" end="${endStr}"/>
      </c:comp-filter>
    </c:comp-filter>
  </c:filter>
</c:calendar-query>`;
    console.log("[Focus Planner] Trying CalDAV REPORT to:", fullUrl);
    const response = await (0, import_obsidian2.requestUrl)({
      url: fullUrl,
      method: "REPORT",
      headers: {
        "Authorization": `Basic ${auth}`,
        "Content-Type": "application/xml; charset=utf-8",
        "Depth": "1"
      },
      body: reportBody,
      throw: false
    });
    console.log("[Focus Planner] CalDAV REPORT response status:", response.status);
    if (response.status === 207) {
      const hasActualCalendarData = response.text.includes("BEGIN:VCALENDAR");
      if (hasActualCalendarData) {
        console.log("[Focus Planner] REPORT contains calendar data, parsing directly");
        const events = this.parseCalDavResponse(response.text, startTime, endTime);
        console.log("[Focus Planner] Parsed events from REPORT:", events.length);
        return events;
      }
      console.log("[Focus Planner] REPORT returned hrefs only, extracting .ics URLs");
      const icsHrefs = [];
      const hrefMatches = response.text.matchAll(/<D:href>([^<]+\.ics)<\/D:href>/gi);
      for (const match of hrefMatches) {
        icsHrefs.push(match[1]);
      }
      console.log("[Focus Planner] Found", icsHrefs.length, ".ics URLs from REPORT");
      if (icsHrefs.length > 0) {
        const multigetEvents = await this.tryCalendarMultiget(fullUrl, auth, icsHrefs, startTime, endTime);
        if (multigetEvents !== null) {
          return multigetEvents;
        }
        console.log("[Focus Planner] Multiget failed, trying individual GET");
        return await this.fetchEventsIndividually(auth, icsHrefs, startTime, endTime);
      }
      return [];
    }
    console.log("[Focus Planner] CalDAV REPORT failed:", response.status);
    return null;
  }
  // Fallback: Use PROPFIND to list all .ics files, then GET each one
  async fetchEventsViaPropfind(calendarUrl, auth, startTime, endTime) {
    const propfindBody = `<?xml version="1.0" encoding="utf-8"?>
<d:propfind xmlns:d="DAV:">
  <d:prop>
    <d:getetag/>
    <d:getcontenttype/>
  </d:prop>
</d:propfind>`;
    console.log("[Focus Planner] CalDAV PROPFIND to list events:", calendarUrl);
    const listResponse = await (0, import_obsidian2.requestUrl)({
      url: calendarUrl,
      method: "PROPFIND",
      headers: {
        "Authorization": `Basic ${auth}`,
        "Content-Type": "application/xml; charset=utf-8",
        "Depth": "1"
      },
      body: propfindBody,
      throw: false
    });
    console.log("[Focus Planner] PROPFIND list response:", listResponse.status);
    if (listResponse.status === 207) {
      const icsHrefs = [];
      const hrefMatches = listResponse.text.matchAll(/<d:href>([^<]+\.ics)<\/d:href>/gi);
      for (const match of hrefMatches) {
        icsHrefs.push(match[1]);
      }
      if (icsHrefs.length === 0) {
        const allHrefs = listResponse.text.matchAll(/<d:href>([^<]+)<\/d:href>/gi);
        for (const match of allHrefs) {
          const href = match[1];
          if (href !== calendarUrl && href.length > calendarUrl.length) {
            icsHrefs.push(href);
          }
        }
      }
      console.log("[Focus Planner] Found", icsHrefs.length, "resources");
      if (icsHrefs.length > 0) {
        const multigetEvents = await this.tryCalendarMultiget(calendarUrl, auth, icsHrefs, startTime, endTime);
        if (multigetEvents !== null) {
          return multigetEvents;
        }
        console.log("[Focus Planner] Falling back to individual GET requests");
        return await this.fetchEventsIndividually(auth, icsHrefs, startTime, endTime);
      }
    }
    console.log("[Focus Planner] PROPFIND failed or empty, trying direct calendar export");
    return await this.tryDirectCalendarExport(calendarUrl, auth, startTime, endTime);
  }
  // Try to get the entire calendar as a single .ics file
  async tryDirectCalendarExport(calendarUrl, auth, startTime, endTime) {
    const exportUrls = [
      calendarUrl.replace(/\/$/, "") + ".ics",
      calendarUrl.replace(/\/$/, "") + "/calendar.ics",
      calendarUrl + "?export"
    ];
    for (const url of exportUrls) {
      console.log("[Focus Planner] Trying calendar export URL:", url);
      const response = await (0, import_obsidian2.requestUrl)({
        url,
        method: "GET",
        headers: {
          "Authorization": `Basic ${auth}`,
          "Accept": "text/calendar"
        },
        throw: false
      });
      console.log("[Focus Planner] Export response status:", response.status);
      if (response.status === 200 && response.text.includes("BEGIN:VCALENDAR")) {
        console.log("[Focus Planner] Got calendar data, parsing...");
        const events = this.parseICalendar(response.text, startTime, endTime);
        console.log("[Focus Planner] Parsed", events.length, "events from export");
        return events;
      }
    }
    console.log("[Focus Planner] Export URLs failed, trying to discover calendars");
    const directResponse = await (0, import_obsidian2.requestUrl)({
      url: calendarUrl,
      method: "GET",
      headers: {
        "Authorization": `Basic ${auth}`,
        "Accept": "text/calendar, text/html, */*"
      },
      throw: false
    });
    console.log("[Focus Planner] Direct GET response:", directResponse.status, "content length:", directResponse.text.length);
    if (directResponse.status === 200 && directResponse.text.includes("BEGIN:VCALENDAR")) {
      const events = this.parseICalendar(directResponse.text, startTime, endTime);
      console.log("[Focus Planner] Parsed", events.length, "events from direct GET");
      return events;
    }
    console.log("[Focus Planner] Response preview:", directResponse.text.substring(0, 500));
    throw new Error("\u65E0\u6CD5\u4ECE CalDAV \u670D\u52A1\u5668\u83B7\u53D6\u65E5\u5386\u6570\u636E\uFF0C\u8BF7\u68C0\u67E5\u914D\u7F6E");
  }
  // Try calendar-multiget REPORT to fetch multiple events at once
  async tryCalendarMultiget(calendarUrl, auth, hrefs, startTime, endTime) {
    const batchSize = 50;
    const allEvents = [];
    for (let i = 0; i < hrefs.length; i += batchSize) {
      const batchHrefs = hrefs.slice(i, i + batchSize);
      const hrefElements = batchHrefs.map((href) => `<D:href>${href}</D:href>`).join("\n    ");
      const multigetBody = `<?xml version="1.0" encoding="utf-8"?>
<C:calendar-multiget xmlns:D="DAV:" xmlns:C="urn:ietf:params:xml:ns:caldav">
  <D:prop>
    <D:getetag/>
    <C:calendar-data/>
  </D:prop>
  ${hrefElements}
</C:calendar-multiget>`;
      console.log("[Focus Planner] Trying calendar-multiget for", batchHrefs.length, "items");
      const response = await (0, import_obsidian2.requestUrl)({
        url: calendarUrl,
        method: "REPORT",
        headers: {
          "Authorization": `Basic ${auth}`,
          "Content-Type": "application/xml; charset=utf-8",
          "Depth": "1"
        },
        body: multigetBody,
        throw: false
      });
      console.log("[Focus Planner] calendar-multiget response:", response.status);
      if (response.status !== 207) {
        console.log("[Focus Planner] calendar-multiget failed:", response.status, response.text.substring(0, 500));
        return null;
      }
      const hasData = response.text.includes("BEGIN:VCALENDAR");
      console.log("[Focus Planner] Multiget response has calendar data:", hasData);
      if (hasData) {
        console.log("[Focus Planner] Multiget response preview:", response.text.substring(0, 2e3));
      }
      const events = this.parseCalDavResponse(response.text, startTime, endTime);
      console.log("[Focus Planner] Parsed", events.length, "events from multiget batch");
      allEvents.push(...events);
    }
    console.log("[Focus Planner] Total events from multiget:", allEvents.length);
    return allEvents;
  }
  // Fallback: GET each .ics file individually
  async fetchEventsIndividually(auth, hrefs, startTime, endTime) {
    const events = [];
    const maxFetch = 200;
    const hrefsToFetch = hrefs.slice(0, maxFetch);
    console.log("[Focus Planner] Fetching", hrefsToFetch.length, "ics files individually");
    for (const href of hrefsToFetch) {
      try {
        const fullUrl = href.startsWith("http") ? href : `${CALDAV_SERVER}${href}`;
        const response = await (0, import_obsidian2.requestUrl)({
          url: fullUrl,
          method: "GET",
          headers: {
            "Authorization": `Basic ${auth}`
          },
          throw: false
        });
        if (response.status === 200) {
          const parsed = this.parseICalendar(response.text, startTime, endTime);
          events.push(...parsed);
        }
      } catch (e) {
        console.warn("[Focus Planner] Failed to fetch:", href, e);
      }
    }
    return events;
  }
  // Format date for CalDAV (UTC format)
  formatDateForCalDav(date) {
    const year = date.getUTCFullYear();
    const month = String(date.getUTCMonth() + 1).padStart(2, "0");
    const day = String(date.getUTCDate()).padStart(2, "0");
    const hour = String(date.getUTCHours()).padStart(2, "0");
    const minute = String(date.getUTCMinutes()).padStart(2, "0");
    const second = String(date.getUTCSeconds()).padStart(2, "0");
    return `${year}${month}${day}T${hour}${minute}${second}Z`;
  }
  // Parse CalDAV response containing iCalendar data
  parseCalDavResponse(xml, queryStart, queryEnd) {
    const events = [];
    const patterns = [
      /<c:calendar-data[^>]*>([\s\S]*?)<\/c:calendar-data>/gi,
      /<cal:calendar-data[^>]*>([\s\S]*?)<\/cal:calendar-data>/gi,
      // Without namespace prefix
      /<calendar-data[^>]*>([\s\S]*?)<\/calendar-data>/gi
    ];
    const processedContent = /* @__PURE__ */ new Set();
    let matchCount = 0;
    for (const pattern of patterns) {
      const matches = xml.matchAll(pattern);
      for (const match of matches) {
        let icsData = match[1];
        const contentHash = icsData.substring(0, 200);
        if (processedContent.has(contentHash)) {
          console.log("[Focus Planner] Skipping duplicate calendar-data");
          continue;
        }
        processedContent.add(contentHash);
        matchCount++;
        console.log("[Focus Planner] Found calendar-data, length:", icsData.length);
        icsData = icsData.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&").replace(/&quot;/g, '"').replace(/&#39;/g, "'").replace(/&#xD;/gi, "\r").replace(/&#xA;/gi, "\n").replace(/&#13;/g, "\r").replace(/&#10;/g, "\n");
        if (matchCount <= 2) {
          console.log("[Focus Planner] Decoded calendar-data preview:", icsData.substring(0, 500));
        }
        const parsedEvents = this.parseICalendar(icsData, queryStart, queryEnd);
        console.log("[Focus Planner] Parsed", parsedEvents.length, "events from this calendar-data");
        events.push(...parsedEvents);
      }
    }
    console.log("[Focus Planner] Total calendar-data elements found:", matchCount);
    if (matchCount === 0 && xml.includes("BEGIN:VCALENDAR")) {
      console.log("[Focus Planner] No calendar-data tags found, but VCALENDAR exists in response");
      const vcalMatches = xml.matchAll(/BEGIN:VCALENDAR[\s\S]*?END:VCALENDAR/g);
      for (const match of vcalMatches) {
        let icsData = match[0].replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&").replace(/&quot;/g, '"').replace(/&#39;/g, "'").replace(/&#xD;/gi, "\r").replace(/&#xA;/gi, "\n").replace(/&#13;/g, "\r").replace(/&#10;/g, "\n");
        const parsedEvents = this.parseICalendar(icsData, queryStart, queryEnd);
        events.push(...parsedEvents);
      }
    }
    const uniqueEvents = /* @__PURE__ */ new Map();
    for (const event of events) {
      if (!uniqueEvents.has(event.id)) {
        uniqueEvents.set(event.id, event);
      }
    }
    console.log("[Focus Planner] After dedup:", uniqueEvents.size, "unique events (from", events.length, "total)");
    return Array.from(uniqueEvents.values());
  }
  // Parse iCalendar (.ics) format
  parseICalendar(icsData, queryStart, queryEnd) {
    const events = [];
    icsData = icsData.replace(/\r\n[ \t]/g, "").replace(/\n[ \t]/g, "");
    const veventMatches = icsData.matchAll(/BEGIN:VEVENT[\s\S]*?END:VEVENT/g);
    for (const match of veventMatches) {
      const vevent = match[0];
      const uid = this.extractIcsProperty(vevent, "UID");
      const summary = this.extractIcsProperty(vevent, "SUMMARY");
      const dtstart = this.extractIcsProperty(vevent, "DTSTART");
      const dtend = this.extractIcsProperty(vevent, "DTEND");
      const rrule = this.extractIcsProperty(vevent, "RRULE");
      const status = this.extractIcsProperty(vevent, "STATUS");
      if ((status == null ? void 0 : status.toUpperCase()) === "CANCELLED") {
        continue;
      }
      if (!dtstart) {
        console.log("[Focus Planner] Skipping event without DTSTART:", summary);
        continue;
      }
      const start = this.parseIcsDateTime(dtstart);
      const end = dtend ? this.parseIcsDateTime(dtend) : new Date(start.getTime() + 36e5);
      if (!start || !end) {
        console.log("[Focus Planner] Cannot parse dates for event:", summary);
        continue;
      }
      const duration = end.getTime() - start.getTime();
      const title = summary || "Untitled Event";
      const category = this.categorizeEvent(title);
      if (!rrule) {
        if (end >= queryStart && start <= queryEnd) {
          events.push({
            id: `caldav-${uid || Date.now()}`,
            title,
            start,
            end,
            category,
            source: "feishu",
            feishuEventId: uid || void 0
          });
        }
        continue;
      }
      const instances = this.expandRecurrence(start, duration, rrule, queryStart, queryEnd);
      for (let i = 0; i < instances.length; i++) {
        const instanceStart = instances[i];
        events.push({
          id: `caldav-${uid || Date.now()}-${i}`,
          title,
          start: instanceStart,
          end: new Date(instanceStart.getTime() + duration),
          category,
          source: "feishu",
          feishuEventId: uid || void 0
        });
      }
    }
    return events;
  }
  // Extract a property from VEVENT
  extractIcsProperty(vevent, property) {
    const regex = new RegExp(`^${property}(?:;[^:]*)?:(.*)$`, "im");
    const match = vevent.match(regex);
    return match ? match[1].trim() : null;
  }
  // Parse iCalendar date/time format
  parseIcsDateTime(dtString) {
    const cleanDt = dtString.replace(/^.*:/, "");
    if (cleanDt.length === 8) {
      const year2 = parseInt(cleanDt.substring(0, 4));
      const month2 = parseInt(cleanDt.substring(4, 6)) - 1;
      const day2 = parseInt(cleanDt.substring(6, 8));
      return new Date(year2, month2, day2, 9, 0, 0);
    }
    if (cleanDt.endsWith("Z")) {
      const year2 = parseInt(cleanDt.substring(0, 4));
      const month2 = parseInt(cleanDt.substring(4, 6)) - 1;
      const day2 = parseInt(cleanDt.substring(6, 8));
      const hour2 = parseInt(cleanDt.substring(9, 11));
      const minute2 = parseInt(cleanDt.substring(11, 13));
      const second2 = parseInt(cleanDt.substring(13, 15));
      return new Date(Date.UTC(year2, month2, day2, hour2, minute2, second2));
    }
    const year = parseInt(cleanDt.substring(0, 4));
    const month = parseInt(cleanDt.substring(4, 6)) - 1;
    const day = parseInt(cleanDt.substring(6, 8));
    const hour = parseInt(cleanDt.substring(9, 11)) || 0;
    const minute = parseInt(cleanDt.substring(11, 13)) || 0;
    const second = parseInt(cleanDt.substring(13, 15)) || 0;
    return new Date(year, month, day, hour, minute, second);
  }
  // Expand recurrence rule (same as feishuApi.ts)
  expandRecurrence(eventStart, duration, rrule, queryStart, queryEnd) {
    var _a;
    const instances = [];
    const rules = {};
    for (const part of rrule.split(";")) {
      const [key, value] = part.split("=");
      if (key && value) {
        rules[key] = value;
      }
    }
    const freq = rules["FREQ"];
    const interval = parseInt(rules["INTERVAL"] || "1");
    const until = rules["UNTIL"] ? this.parseIcsDateTime(rules["UNTIL"]) : null;
    const count = rules["COUNT"] ? parseInt(rules["COUNT"]) : null;
    const byDay = ((_a = rules["BYDAY"]) == null ? void 0 : _a.split(",")) || [];
    let repeatEnd = queryEnd;
    if (until && until < repeatEnd) {
      repeatEnd = until;
    }
    let current = new Date(eventStart);
    let instanceCount = 0;
    const maxIterations = 1e3;
    for (let i = 0; i < maxIterations && current <= repeatEnd; i++) {
      if (count && instanceCount >= count)
        break;
      const instanceEnd = new Date(current.getTime() + duration);
      if (instanceEnd >= queryStart && current <= queryEnd) {
        if (byDay.length === 0 || this.matchesByDay(current, byDay)) {
          instances.push(new Date(current));
          instanceCount++;
        }
      }
      switch (freq) {
        case "DAILY":
          current.setDate(current.getDate() + interval);
          break;
        case "WEEKLY":
          if (byDay.length > 0) {
            current.setDate(current.getDate() + 1);
          } else {
            current.setDate(current.getDate() + 7 * interval);
          }
          break;
        case "MONTHLY":
          current.setMonth(current.getMonth() + interval);
          break;
        case "YEARLY":
          current.setFullYear(current.getFullYear() + interval);
          break;
        default:
          return [];
      }
    }
    return instances;
  }
  matchesByDay(date, byDay) {
    const dayMap = {
      0: "SU",
      1: "MO",
      2: "TU",
      3: "WE",
      4: "TH",
      5: "FR",
      6: "SA"
    };
    const dayCode = dayMap[date.getDay()];
    return byDay.some((d) => d.includes(dayCode));
  }
  // Categorize event based on title keywords
  categorizeEvent(title) {
    const lowerTitle = title.toLowerCase();
    const categoryOrder = [
      "rest" /* REST */,
      "meeting" /* MEETING */,
      "personal" /* PERSONAL */,
      "admin" /* ADMIN */,
      "focus" /* FOCUS */
    ];
    for (const category of categoryOrder) {
      const keywords = this.categoryKeywords[category] || [];
      for (const keyword of keywords) {
        if (lowerTitle.includes(keyword.toLowerCase())) {
          return category;
        }
      }
    }
    return "meeting" /* MEETING */;
  }
};

// src/dailyNoteParser.ts
var import_obsidian3 = require("obsidian");
var DailyNoteParser = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  // Get daily note path for a date
  getDailyNotePath(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    return this.settings.dailyNotePath.replace(/YYYY/g, String(year)).replace(/MM/g, month).replace(/DD/g, day);
  }
  // Parse events from a daily note
  async parseEventsFromDailyNote(date) {
    const path2 = this.getDailyNotePath(date);
    const file = this.app.vault.getAbstractFileByPath(path2);
    if (!(file instanceof import_obsidian3.TFile)) {
      return [];
    }
    const content = await this.app.vault.read(file);
    return this.parseEventsFromContent(content, date, path2);
  }
  // Parse events from markdown content
  parseEventsFromContent(content, date, filePath) {
    const events = [];
    const lines = content.split("\n");
    let currentCategory = null;
    const headingPatterns = {
      "### \u{1F3AF} \u4E13\u6CE8\u65F6\u95F4": "focus" /* FOCUS */,
      "### \u{1F4C5} \u4F1A\u8BAE": "meeting" /* MEETING */,
      "### \u{1F3E0} \u5BB6\u5EAD/\u4E2A\u4EBA": "personal" /* PERSONAL */,
      "### \u{1F634} \u4F11\u606F": "rest" /* REST */
    };
    const timePattern = /\[startTime::\s*(\d{1,2}:\d{2})\s*\]\s*\[endTime::\s*(\d{1,2}:\d{2})\s*\]/;
    const aiPlanningPomos = this.parseAIPlanningTable(content);
    for (const line of lines) {
      for (const [heading, category] of Object.entries(headingPatterns)) {
        if (line.trim().startsWith(heading)) {
          currentCategory = category;
          break;
        }
      }
      if (currentCategory && line.trim().startsWith("-")) {
        const match = line.match(timePattern);
        if (match) {
          const [, startTimeStr, endTimeStr] = match;
          const titleMatch = line.match(/^-\s*(.+?)\s*\[startTime/);
          const title = titleMatch ? titleMatch[1].trim() : "Untitled";
          const [startHour, startMin] = startTimeStr.split(":").map(Number);
          const [endHour, endMin] = endTimeStr.split(":").map(Number);
          const startDate = new Date(date);
          startDate.setHours(startHour, startMin, 0, 0);
          const endDate = new Date(date);
          endDate.setHours(endHour, endMin, 0, 0);
          let plannedPomodoros;
          const pomoMatch = title.match(/(\d+)üçÖ/);
          if (pomoMatch) {
            plannedPomodoros = parseInt(pomoMatch[1]);
          } else {
            const cleanTitle2 = title.replace(/\d+üçÖ/, "").trim();
            plannedPomodoros = this.findPomoInAIPlanning(cleanTitle2, aiPlanningPomos);
          }
          let taskSourcePath;
          let taskLineNumber;
          const taskPathMatch = line.match(/\[taskPath::\s*([^\]]+)\s*\]/);
          const taskLineMatch = line.match(/\[taskLine::\s*(\d+)\s*\]/);
          if (taskPathMatch) {
            taskSourcePath = taskPathMatch[1].trim();
          }
          if (taskLineMatch) {
            taskLineNumber = parseInt(taskLineMatch[1]);
          }
          const cleanTitle = title.replace(/\d+üçÖ/, "").trim();
          events.push({
            id: `local-${filePath}-${startTimeStr}-${endTimeStr}-${cleanTitle}`,
            title: cleanTitle,
            start: startDate,
            end: endDate,
            category: currentCategory,
            source: "local",
            filePath,
            plannedPomodoros,
            taskSourcePath,
            taskLineNumber
          });
        }
      }
    }
    return events;
  }
  // Parse AI planning table to extract task -> pomodoro mapping
  parseAIPlanningTable(content) {
    const pomoMap = /* @__PURE__ */ new Map();
    const tableRowPattern = /\|\s*([^|]+)\s*\|\s*(\d+)üçÖ\s*\|/g;
    let match;
    while ((match = tableRowPattern.exec(content)) !== null) {
      let taskName = match[1].trim();
      const pomos = parseInt(match[2]);
      taskName = taskName.replace(/^[üìöüë®‚Äçüë©‚Äçüë¶üöÄüß†üìùüè†]\s*/, "").trim();
      if (taskName && pomos > 0) {
        pomoMap.set(taskName.toLowerCase(), pomos);
      }
    }
    return pomoMap;
  }
  // Find pomodoro count for a task from AI planning
  findPomoInAIPlanning(taskTitle, aiPomos) {
    const normalizedTitle = taskTitle.toLowerCase();
    if (aiPomos.has(normalizedTitle)) {
      return aiPomos.get(normalizedTitle);
    }
    for (const [key, value] of aiPomos) {
      if (normalizedTitle.includes(key) || key.includes(normalizedTitle)) {
        return value;
      }
    }
    return void 0;
  }
  // Parse pomodoro records from daily note
  async parsePomodorosFromDailyNote(date) {
    const path2 = this.getDailyNotePath(date);
    const file = this.app.vault.getAbstractFileByPath(path2);
    if (!(file instanceof import_obsidian3.TFile)) {
      return [];
    }
    const content = await this.app.vault.read(file);
    return this.parsePomodorosFromContent(content, date);
  }
  // Parse pomodoro records from content
  parsePomodorosFromContent(content, date) {
    const records = [];
    const pomoPattern = /üçÖ\s*\(pomodoro::\w+\)\s*\(duration::\s*(\d+)m\)\s*\(begin::\s*([\d-]+\s+[\d:]+)\)\s*-\s*\(end::\s*([\d-]+\s+[\d:]+)\)/g;
    let match;
    while ((match = pomoPattern.exec(content)) !== null) {
      const [, durationStr, beginStr, endStr] = match;
      const startTime = new Date(beginStr.replace(" ", "T"));
      const endTime = new Date(endStr.replace(" ", "T"));
      records.push({
        id: `pomo-${startTime.getTime()}`,
        startTime,
        endTime,
        duration: parseInt(durationStr),
        category: "focus" /* FOCUS */
        // Default to focus
      });
    }
    return records;
  }
  // Write events to daily note's Day Planner section
  async writeEventsToDailyNote(date, events) {
    const path2 = this.getDailyNotePath(date);
    let file = this.app.vault.getAbstractFileByPath(path2);
    if (!file) {
      await this.createDailyNote(date);
      file = this.app.vault.getAbstractFileByPath(path2);
    }
    if (!file) {
      throw new Error(`Failed to create daily note at ${path2}`);
    }
    const content = await this.app.vault.read(file);
    const updatedContent = this.updateDayPlannerSection(content, events);
    await this.app.vault.modify(file, updatedContent);
  }
  // Create a new daily note
  async createDailyNote(date) {
    const path2 = this.getDailyNotePath(date);
    const dir = path2.substring(0, path2.lastIndexOf("/"));
    const existingDir = this.app.vault.getAbstractFileByPath(dir);
    if (!existingDir) {
      await this.app.vault.createFolder(dir);
    }
    const template = this.getDailyNoteTemplate(date);
    await this.app.vault.create(path2, template);
  }
  // Get daily note template
  getDailyNoteTemplate(date) {
    const dateStr = date.toISOString().split("T")[0];
    return `
# **\u4ECA\u65E5\u4E3B\u9898\uFF1A** \`\u5F85\u586B\u5199\`

# \u4ECA\u65E5TODO
%%Your Record%%

\`\`\`tasks
((folder includes 1. Projects) OR (folder includes 2. Areas) OR (folder includes 3. Resources) OR (filename includes Inbox)) AND ((due on today) OR (status.type is IN_PROGRESS) OR (due before today))
not done
sort by due
\`\`\`

# Day planner
### \u4ECA\u5929\u4ECE\u54EA\u5F00\u59CB\uFF1F

\u5F85\u586B\u5199

### \u{1F3AF} \u4E13\u6CE8\u65F6\u95F4

### \u{1F4C5} \u4F1A\u8BAE

### \u{1F3E0} \u5BB6\u5EAD/\u4E2A\u4EBA

### \u{1F634} \u4F11\u606F

## \u{1F4AD} \u6BCF\u65E5\u53CD\u601D


---

## Completed today
%%List of tasks completed today, extracted from all notes%%
\`\`\`PeriodicPARA
TaskDoneListByTime
\`\`\`
`;
  }
  // Update Day Planner section with events
  // IMPORTANT: Only update sections that have events from sync, preserve local focus time
  updateDayPlannerSection(content, events) {
    const byCategory = {
      ["focus" /* FOCUS */]: [],
      ["meeting" /* MEETING */]: [],
      ["personal" /* PERSONAL */]: [],
      ["rest" /* REST */]: [],
      ["admin" /* ADMIN */]: []
    };
    for (const event of events) {
      byCategory[event.category].push(event);
    }
    for (const category of Object.values(EventCategory)) {
      byCategory[category].sort((a, b) => a.start.getTime() - b.start.getTime());
    }
    const sectionHeadings = {
      ["focus" /* FOCUS */]: "### \u{1F3AF} \u4E13\u6CE8\u65F6\u95F4",
      ["meeting" /* MEETING */]: "### \u{1F4C5} \u4F1A\u8BAE",
      ["personal" /* PERSONAL */]: "### \u{1F3E0} \u5BB6\u5EAD/\u4E2A\u4EBA",
      ["rest" /* REST */]: "### \u{1F634} \u4F11\u606F",
      ["admin" /* ADMIN */]: "### \u{1F4DD} \u4E8B\u52A1"
    };
    const headingToCategory = {};
    for (const [cat, heading] of Object.entries(sectionHeadings)) {
      headingToCategory[heading] = cat;
    }
    const lines = content.split("\n");
    const result = [];
    let currentSyncCategory = null;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmedLine = line.trim();
      let foundCategory = null;
      for (const [heading, category] of Object.entries(headingToCategory)) {
        if (trimmedLine === heading || trimmedLine.startsWith(heading)) {
          foundCategory = category;
          break;
        }
      }
      if (foundCategory !== null) {
        result.push(line);
        if (byCategory[foundCategory].length > 0) {
          currentSyncCategory = foundCategory;
          for (const event of byCategory[foundCategory]) {
            const startTime = this.formatTime(event.start);
            const endTime = this.formatTime(event.end);
            let eventLine = `- ${event.title} [startTime:: ${startTime}] [endTime:: ${endTime}]`;
            if (event.taskSourcePath && event.taskLineNumber) {
              eventLine += ` [taskPath:: ${event.taskSourcePath}] [taskLine:: ${event.taskLineNumber}]`;
            }
            result.push(eventLine);
          }
        } else {
          currentSyncCategory = null;
        }
        continue;
      }
      if (trimmedLine.startsWith("### ") || trimmedLine.startsWith("## ")) {
        currentSyncCategory = null;
        result.push(line);
        continue;
      }
      if (currentSyncCategory !== null) {
        if (trimmedLine.startsWith("-") && line.includes("[startTime::")) {
          continue;
        }
      }
      result.push(line);
    }
    return result.join("\n");
  }
  // Generate section content from events
  generateSectionContent(events) {
    if (events.length === 0) {
      return "";
    }
    return events.map((event) => {
      const startTime = this.formatTime(event.start);
      const endTime = this.formatTime(event.end);
      let line = `- ${event.title} [startTime:: ${startTime}] [endTime:: ${endTime}]`;
      if (event.taskSourcePath && event.taskLineNumber) {
        line += ` [taskPath:: ${event.taskSourcePath}] [taskLine:: ${event.taskLineNumber}]`;
      }
      return line;
    }).join("\n");
  }
  // Format time as HH:MM
  formatTime(date) {
    return `${String(date.getHours()).padStart(2, "0")}:${String(date.getMinutes()).padStart(2, "0")}`;
  }
  // Update an event's time in the daily note
  async updateEventInDailyNote(event, newStart, newEnd) {
    if (!event.filePath) {
      throw new Error("Event has no file path");
    }
    const file = this.app.vault.getAbstractFileByPath(event.filePath);
    if (!(file instanceof import_obsidian3.TFile)) {
      throw new Error(`File not found: ${event.filePath}`);
    }
    const content = await this.app.vault.read(file);
    const oldStartTime = this.formatTime(event.start);
    const oldEndTime = this.formatTime(event.end);
    const newStartTime = this.formatTime(newStart);
    const newEndTime = this.formatTime(newEnd);
    const eventLinePattern = new RegExp(
      `^(-\\s*${this.escapeRegex(event.title)}\\s*)\\[startTime::\\s*${oldStartTime}\\s*\\]\\s*\\[endTime::\\s*${oldEndTime}\\s*\\](.*)$`,
      "gm"
    );
    const updatedContent = content.replace(
      eventLinePattern,
      `$1[startTime:: ${newStartTime}] [endTime:: ${newEndTime}]$2`
    );
    if (updatedContent === content) {
      const relaxedPattern = new RegExp(
        `^(-\\s*.+?)\\[startTime::\\s*${oldStartTime}\\s*\\]\\s*\\[endTime::\\s*${oldEndTime}\\s*\\](.*)$`,
        "gm"
      );
      const relaxedContent = content.replace(
        relaxedPattern,
        (match, prefix, suffix) => {
          if (match.includes(event.title)) {
            return `${prefix}[startTime:: ${newStartTime}] [endTime:: ${newEndTime}]${suffix}`;
          }
          return match;
        }
      );
      if (relaxedContent !== content) {
        await this.app.vault.modify(file, relaxedContent);
        return;
      }
      throw new Error(`Could not find event to update: ${event.title}`);
    }
    await this.app.vault.modify(file, updatedContent);
  }
  // Remove an event from a daily note
  async removeEventFromDailyNote(date, event) {
    const path2 = this.getDailyNotePath(date);
    const file = this.app.vault.getAbstractFileByPath(path2);
    if (!(file instanceof import_obsidian3.TFile)) {
      throw new Error(`File not found: ${path2}`);
    }
    const content = await this.app.vault.read(file);
    const startTime = this.formatTime(event.start);
    const endTime = this.formatTime(event.end);
    const lines = content.split("\n");
    const filteredLines = lines.filter((line) => {
      if (!line.trim().startsWith("-"))
        return true;
      if (!line.includes(`[startTime:: ${startTime}]`))
        return true;
      if (!line.includes(`[endTime:: ${endTime}]`))
        return true;
      if (!line.includes(event.title))
        return true;
      return false;
    });
    const updatedContent = filteredLines.join("\n");
    await this.app.vault.modify(file, updatedContent);
  }
  // Add an event to a daily note
  async addEventToDailyNote(date, event) {
    const path2 = this.getDailyNotePath(date);
    let file = this.app.vault.getAbstractFileByPath(path2);
    if (!file) {
      await this.createDailyNote(date);
      file = this.app.vault.getAbstractFileByPath(path2);
    }
    if (!file) {
      throw new Error(`Failed to create daily note at ${path2}`);
    }
    const content = await this.app.vault.read(file);
    const startTime = this.formatTime(event.start);
    const endTime = this.formatTime(event.end);
    let eventLine = `- ${event.title} [startTime:: ${startTime}] [endTime:: ${endTime}]`;
    if (event.taskSourcePath && event.taskLineNumber) {
      eventLine += ` [taskPath:: ${event.taskSourcePath}] [taskLine:: ${event.taskLineNumber}]`;
    }
    const sectionHeadings = {
      ["focus" /* FOCUS */]: "### \u{1F3AF} \u4E13\u6CE8\u65F6\u95F4",
      ["meeting" /* MEETING */]: "### \u{1F4C5} \u4F1A\u8BAE",
      ["personal" /* PERSONAL */]: "### \u{1F3E0} \u5BB6\u5EAD/\u4E2A\u4EBA",
      ["rest" /* REST */]: "### \u{1F634} \u4F11\u606F",
      ["admin" /* ADMIN */]: "### \u{1F4DD} \u4E8B\u52A1"
    };
    const heading = sectionHeadings[event.category];
    const lines = content.split("\n");
    let insertIndex = -1;
    let inSection = false;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (line.trim().startsWith(heading)) {
        inSection = true;
        insertIndex = i + 1;
        continue;
      }
      if (inSection) {
        if (line.trim().startsWith("### ") || line.trim().startsWith("## ")) {
          break;
        }
        if (line.trim().startsWith("-") && line.includes("[startTime::")) {
          insertIndex = i + 1;
        }
      }
    }
    if (insertIndex === -1) {
      throw new Error(`Could not find section ${heading} in daily note`);
    }
    lines.splice(insertIndex, 0, eventLine);
    const updatedContent = lines.join("\n");
    await this.app.vault.modify(file, updatedContent);
  }
  // Helper to escape regex special characters
  escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
};

// src/statsManager.ts
var StatsManager = class {
  constructor(app, settings, dailyNoteParser) {
    this.app = app;
    this.settings = settings;
    this.dailyNoteParser = dailyNoteParser;
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  // Calculate daily stats from events and pomodoros
  async getDailyStats(date) {
    const events = await this.dailyNoteParser.parseEventsFromDailyNote(date);
    const pomodoros = await this.dailyNoteParser.parsePomodorosFromDailyNote(date);
    const byCategory = {
      ["focus" /* FOCUS */]: 0,
      ["meeting" /* MEETING */]: 0,
      ["personal" /* PERSONAL */]: 0,
      ["rest" /* REST */]: 0,
      ["admin" /* ADMIN */]: 0
    };
    let totalMinutes = 0;
    let pomodorosPlanned = 0;
    for (const event of events) {
      const durationMs = event.end.getTime() - event.start.getTime();
      const durationMin = Math.round(durationMs / 6e4);
      byCategory[event.category] += durationMin;
      totalMinutes += durationMin;
      if (event.plannedPomodoros) {
        pomodorosPlanned += event.plannedPomodoros;
      }
    }
    return {
      date: this.formatDate(date),
      totalMinutes,
      pomodorosCompleted: pomodoros.length,
      pomodorosPlanned,
      byCategory
    };
  }
  // Calculate weekly stats
  async getWeeklyStats(weekStart) {
    const dailyStats = [];
    const byCategory = {
      ["focus" /* FOCUS */]: 0,
      ["meeting" /* MEETING */]: 0,
      ["personal" /* PERSONAL */]: 0,
      ["rest" /* REST */]: 0,
      ["admin" /* ADMIN */]: 0
    };
    let totalMinutes = 0;
    let totalPomodoros = 0;
    for (let i = 0; i < 7; i++) {
      const date = new Date(weekStart);
      date.setDate(weekStart.getDate() + i);
      const dayStats = await this.getDailyStats(date);
      dailyStats.push(dayStats);
      totalMinutes += dayStats.totalMinutes;
      totalPomodoros += dayStats.pomodorosCompleted;
      for (const category of Object.values(EventCategory)) {
        byCategory[category] += dayStats.byCategory[category];
      }
    }
    const weekEnd = new Date(weekStart);
    weekEnd.setDate(weekStart.getDate() + 6);
    return {
      weekNumber: this.getISOWeekNumber(weekStart),
      startDate: this.formatDate(weekStart),
      endDate: this.formatDate(weekEnd),
      dailyStats,
      totalMinutes,
      totalPomodoros,
      byCategory
    };
  }
  // Associate pomodoros with events based on time overlap
  associatePomodorosWithEvents(pomodoros, events) {
    const eventPomodoros = /* @__PURE__ */ new Map();
    for (const pomo of pomodoros) {
      for (const event of events) {
        if (this.timeOverlaps(pomo.startTime, pomo.endTime, event.start, event.end)) {
          if (!eventPomodoros.has(event.id)) {
            eventPomodoros.set(event.id, []);
          }
          eventPomodoros.get(event.id).push(pomo);
          break;
        }
      }
    }
    return eventPomodoros;
  }
  // Check if two time ranges overlap
  timeOverlaps(start1, end1, start2, end2) {
    return start1 < end2 && end1 > start2;
  }
  // Update event with pomodoro counts
  updateEventPomodoroCounts(events, pomodoros) {
    const eventPomoMap = this.associatePomodorosWithEvents(pomodoros, events);
    return events.map((event) => {
      const pomoList = eventPomoMap.get(event.id) || [];
      return {
        ...event,
        completedPomodoros: pomoList.length
      };
    });
  }
  // Get events with pomodoro progress for a date range
  async getEventsWithProgress(startDate, endDate) {
    const allEvents = [];
    const allPomodoros = [];
    const current = new Date(startDate);
    while (current <= endDate) {
      const events = await this.dailyNoteParser.parseEventsFromDailyNote(current);
      const pomodoros = await this.dailyNoteParser.parsePomodorosFromDailyNote(current);
      allEvents.push(...events);
      allPomodoros.push(...pomodoros);
      current.setDate(current.getDate() + 1);
    }
    return this.updateEventPomodoroCounts(allEvents, allPomodoros);
  }
  // Format date as YYYY-MM-DD
  formatDate(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    return `${year}-${month}-${day}`;
  }
  // Get ISO week number
  getISOWeekNumber(date) {
    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    const dayNum = d.getUTCDay() || 7;
    d.setUTCDate(d.getUTCDate() + 4 - dayNum);
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    const weekNo = Math.ceil(((d.getTime() - yearStart.getTime()) / 864e5 + 1) / 7);
    return `${d.getUTCFullYear()}-W${String(weekNo).padStart(2, "0")}`;
  }
  // Generate time distribution chart data
  generateTimeDistribution(stats) {
    const distribution = [];
    const COLORS = {
      ["focus" /* FOCUS */]: "#22c55e",
      ["meeting" /* MEETING */]: "#3b82f6",
      ["personal" /* PERSONAL */]: "#f97316",
      ["rest" /* REST */]: "#6b7280",
      ["admin" /* ADMIN */]: "#eab308"
    };
    const LABELS = {
      ["focus" /* FOCUS */]: "\u4E13\u6CE8\u5B66\u4E60",
      ["meeting" /* MEETING */]: "\u4F1A\u8BAE",
      ["personal" /* PERSONAL */]: "\u5BB6\u5EAD/\u4E2A\u4EBA",
      ["rest" /* REST */]: "\u4F11\u606F",
      ["admin" /* ADMIN */]: "\u4E8B\u52A1"
    };
    for (const category of Object.values(EventCategory)) {
      const minutes = stats.byCategory[category];
      if (minutes > 0) {
        distribution.push({
          category: LABELS[category],
          hours: Math.round(minutes / 60 * 10) / 10,
          color: COLORS[category]
        });
      }
    }
    return distribution.sort((a, b) => b.hours - a.hours);
  }
};

// src/calendarView.ts
var import_obsidian4 = require("obsidian");
var VIEW_TYPE_FOCUS_PLANNER = "focus-planner-view";
var START_HOUR = 7;
var END_HOUR = 22;
var HOUR_HEIGHT = 60;
var TOTAL_HOURS = END_HOUR - START_HOUR;
var SNAP_MINUTES = 15;
var EventCreateModal = class extends import_obsidian4.Modal {
  constructor(app, date, startHour, startMinute, onSubmit) {
    super(app);
    this.title = "";
    this.category = "focus" /* FOCUS */;
    this.date = date;
    this.startHour = startHour;
    this.startMinute = startMinute;
    this.endHour = startHour + 1;
    this.endMinute = startMinute;
    this.onSubmit = onSubmit;
    if (this.endHour >= END_HOUR) {
      this.endHour = END_HOUR;
      this.endMinute = 0;
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("event-create-modal");
    contentEl.createEl("h2", { text: "\u521B\u5EFA\u65B0\u65E5\u7A0B" });
    const dateStr = `${this.date.getMonth() + 1}/${this.date.getDate()}`;
    contentEl.createEl("p", { text: `\u65E5\u671F: ${dateStr}`, cls: "event-date-display" });
    new import_obsidian4.Setting(contentEl).setName("\u6807\u9898").addText((text) => {
      text.setPlaceholder("\u8F93\u5165\u65E5\u7A0B\u6807\u9898").onChange((value) => this.title = value);
      text.inputEl.focus();
    });
    new import_obsidian4.Setting(contentEl).setName("\u7C7B\u522B").addDropdown((dropdown) => {
      dropdown.addOption("focus" /* FOCUS */, "\u{1F3AF} \u4E13\u6CE8\u65F6\u95F4");
      dropdown.addOption("meeting" /* MEETING */, "\u{1F4C5} \u4F1A\u8BAE");
      dropdown.addOption("personal" /* PERSONAL */, "\u{1F3E0} \u5BB6\u5EAD/\u4E2A\u4EBA");
      dropdown.addOption("rest" /* REST */, "\u{1F634} \u4F11\u606F");
      dropdown.addOption("admin" /* ADMIN */, "\u{1F4DD} \u4E8B\u52A1");
      dropdown.setValue(this.category);
      dropdown.onChange((value) => this.category = value);
    });
    const startTimeContainer = contentEl.createDiv({ cls: "time-input-container" });
    startTimeContainer.createSpan({ text: "\u5F00\u59CB\u65F6\u95F4: " });
    const startTimeSelect = this.createTimeSelect(startTimeContainer, this.startHour, this.startMinute, (h, m) => {
      this.startHour = h;
      this.startMinute = m;
    });
    const endTimeContainer = contentEl.createDiv({ cls: "time-input-container" });
    endTimeContainer.createSpan({ text: "\u7ED3\u675F\u65F6\u95F4: " });
    const endTimeSelect = this.createTimeSelect(endTimeContainer, this.endHour, this.endMinute, (h, m) => {
      this.endHour = h;
      this.endMinute = m;
    });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const cancelBtn = buttonContainer.createEl("button", { text: "\u53D6\u6D88" });
    cancelBtn.addEventListener("click", () => this.close());
    const submitBtn = buttonContainer.createEl("button", { text: "\u521B\u5EFA", cls: "mod-cta" });
    submitBtn.addEventListener("click", () => this.handleSubmit());
    contentEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        this.handleSubmit();
      }
    });
  }
  createTimeSelect(container, hour, minute, onChange) {
    let currentHour = hour;
    let currentMinute = minute;
    const hourSelect = container.createEl("select", { cls: "time-select" });
    for (let h = START_HOUR; h <= END_HOUR; h++) {
      const opt = hourSelect.createEl("option", { value: String(h), text: String(h).padStart(2, "0") });
      if (h === hour)
        opt.selected = true;
    }
    hourSelect.addEventListener("change", () => {
      currentHour = parseInt(hourSelect.value);
      onChange(currentHour, currentMinute);
    });
    container.createSpan({ text: ":" });
    const minuteSelect = container.createEl("select", { cls: "time-select" });
    for (let m = 0; m < 60; m += SNAP_MINUTES) {
      const opt = minuteSelect.createEl("option", { value: String(m), text: String(m).padStart(2, "0") });
      if (m === minute)
        opt.selected = true;
    }
    minuteSelect.addEventListener("change", () => {
      currentMinute = parseInt(minuteSelect.value);
      onChange(currentHour, currentMinute);
    });
  }
  handleSubmit() {
    if (!this.title.trim()) {
      new import_obsidian4.Notice("\u8BF7\u8F93\u5165\u65E5\u7A0B\u6807\u9898");
      return;
    }
    const startTotal = this.startHour * 60 + this.startMinute;
    const endTotal = this.endHour * 60 + this.endMinute;
    if (endTotal <= startTotal) {
      new import_obsidian4.Notice("\u7ED3\u675F\u65F6\u95F4\u5FC5\u987B\u665A\u4E8E\u5F00\u59CB\u65F6\u95F4");
      return;
    }
    const startDate = new Date(this.date);
    startDate.setHours(this.startHour, this.startMinute, 0, 0);
    const endDate = new Date(this.date);
    endDate.setHours(this.endHour, this.endMinute, 0, 0);
    this.onSubmit({
      title: this.title.trim(),
      category: this.category,
      start: startDate,
      end: endDate
    });
    this.close();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var FocusPlannerView = class extends import_obsidian4.ItemView {
  constructor(leaf) {
    super(leaf);
    this.events = [];
    this.calendarContainer = null;
    this.summaryContainer = null;
    this.dragState = null;
    this.dayColumnsContainer = null;
    // Task panel
    this.taskPanel = null;
    this.taskPanelData = null;
    // Callbacks
    this.onSyncFeishu = null;
    this.onEventClick = null;
    this.onStartPomodoro = null;
    this.onEventUpdate = null;
    this.onEventCreate = null;
    this.onEventDelete = null;
    this.getWeeklyStats = null;
    this.onWeekChange = null;
    // Task panel callbacks
    this.onGetTasks = null;
    this.onTaskInferCategory = null;
    this.handleDragMove = (e) => {
      if (!this.dragState)
        return;
      const deltaY = e.clientY - this.dragState.startY;
      const deltaX = e.clientX - this.dragState.startX;
      if (!this.dragState.isDragging) {
        if (Math.abs(deltaY) > 5 || Math.abs(deltaX) > 5) {
          this.dragState.isDragging = true;
          this.dragState.eventEl.addClass("dragging");
          document.body.addClass("focus-planner-dragging");
        } else {
          return;
        }
      }
      let newTop = this.dragState.originalTop + deltaY;
      const snapPx = SNAP_MINUTES / 60 * HOUR_HEIGHT;
      newTop = Math.round(newTop / snapPx) * snapPx;
      const maxTop = TOTAL_HOURS * HOUR_HEIGHT - 30;
      newTop = Math.max(0, Math.min(newTop, maxTop));
      this.dragState.eventEl.style.top = `${newTop}px`;
      if (this.dayColumnsContainer) {
        const dayColumns = this.dayColumnsContainer.querySelectorAll(".day-column");
        let newDayIndex = this.dragState.originalDayIndex;
        for (let i = 0; i < dayColumns.length; i++) {
          const col = dayColumns[i];
          const rect = col.getBoundingClientRect();
          if (e.clientX >= rect.left && e.clientX <= rect.right) {
            newDayIndex = i;
            break;
          }
        }
        if (newDayIndex !== this.dragState.currentDayIndex) {
          const newColumn = dayColumns[newDayIndex];
          if (newColumn) {
            newColumn.appendChild(this.dragState.eventEl);
            this.dragState.currentDayIndex = newDayIndex;
          }
        }
      }
      this.updateDragTimeDisplay();
    };
    this.handleDragEnd = async (e) => {
      document.removeEventListener("mousemove", this.handleDragMove);
      document.removeEventListener("mouseup", this.handleDragEnd);
      if (!this.dragState)
        return;
      const { event, eventEl, isDragging, originalDayIndex, currentDayIndex, originalTop } = this.dragState;
      eventEl.removeClass("dragging");
      document.body.removeClass("focus-planner-dragging");
      if (!isDragging) {
        this.dragState = null;
        this.showEventMenu(e, event);
        return;
      }
      const newTop = parseFloat(eventEl.style.top) || 0;
      const dayChanged = currentDayIndex !== originalDayIndex;
      const timeChanged = Math.abs(newTop - originalTop) > 1;
      if (!dayChanged && !timeChanged) {
        this.dragState = null;
        return;
      }
      const hoursFromTop = newTop / HOUR_HEIGHT;
      const newStartHour = Math.floor(START_HOUR + hoursFromTop);
      const newStartMinute = Math.round(hoursFromTop % 1 * 60 / SNAP_MINUTES) * SNAP_MINUTES;
      const durationMs = event.end.getTime() - event.start.getTime();
      const newDate = new Date(this.currentWeekStart);
      newDate.setDate(newDate.getDate() + currentDayIndex);
      const newStart = new Date(newDate);
      newStart.setHours(newStartHour, newStartMinute, 0, 0);
      const newEnd = new Date(newStart.getTime() + durationMs);
      if (newEnd.getHours() > END_HOUR || newEnd.getHours() === END_HOUR && newEnd.getMinutes() > 0) {
        newEnd.setHours(END_HOUR, 0, 0, 0);
      }
      this.dragState = null;
      if (this.onEventUpdate) {
        try {
          await this.onEventUpdate(event, newStart, newEnd);
          new import_obsidian4.Notice(`\u{1F4C5} \u5DF2\u79FB\u52A8: ${event.title} \u2192 ${this.formatTime(newStart)}-${this.formatTime(newEnd)}`);
        } catch (error) {
          new import_obsidian4.Notice(`\u79FB\u52A8\u5931\u8D25: ${error.message}`);
          this.renderCalendar();
        }
      } else {
        this.renderCalendar();
      }
    };
    const today = new Date();
    this.currentWeekStart = new Date(today);
    const day = today.getDay();
    const diff = today.getDate() - day + (day === 0 ? -6 : 1);
    this.currentWeekStart.setDate(diff);
    this.currentWeekStart.setHours(0, 0, 0, 0);
  }
  getViewType() {
    return VIEW_TYPE_FOCUS_PLANNER;
  }
  getDisplayText() {
    return "Focus Planner";
  }
  getIcon() {
    return "calendar-clock";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("focus-planner-container");
    const header = container.createDiv({ cls: "focus-planner-header" });
    this.createHeader(header);
    const mainContent = container.createDiv({ cls: "focus-planner-main" });
    this.calendarContainer = mainContent.createDiv({ cls: "focus-planner-calendar" });
    this.taskPanel = mainContent.createDiv({ cls: "focus-planner-task-panel" });
    this.summaryContainer = container.createDiv({ cls: "focus-planner-summary" });
    await this.loadEventsForCurrentWeek();
    await this.loadTasksForPanel();
    this.renderCalendar();
    this.renderTaskPanel();
    this.updateSummaryBar();
  }
  createHeader(container) {
    const titleRow = container.createDiv({ cls: "header-title-row" });
    const nav = titleRow.createDiv({ cls: "week-nav" });
    const prevBtn = nav.createEl("button", { cls: "nav-btn", text: "\u2039" });
    prevBtn.addEventListener("click", () => this.navigateWeek(-1));
    const weekTitle = nav.createEl("span", { cls: "week-title" });
    this.updateWeekTitle(weekTitle);
    const nextBtn = nav.createEl("button", { cls: "nav-btn", text: "\u203A" });
    nextBtn.addEventListener("click", () => this.navigateWeek(1));
    const todayBtn = nav.createEl("button", { cls: "today-btn", text: "\u4ECA\u5929" });
    todayBtn.addEventListener("click", () => this.goToToday());
    const controls = titleRow.createDiv({ cls: "focus-planner-controls" });
    const syncBtn = controls.createEl("button", {
      cls: "focus-planner-btn",
      text: "\u540C\u6B65\u98DE\u4E66"
    });
    syncBtn.addEventListener("click", async () => {
      if (this.onSyncFeishu) {
        syncBtn.textContent = "\u540C\u6B65\u4E2D...";
        syncBtn.disabled = true;
        try {
          await this.onSyncFeishu();
          syncBtn.textContent = "\u540C\u6B65\u6210\u529F!";
          setTimeout(() => {
            syncBtn.textContent = "\u540C\u6B65\u98DE\u4E66";
            syncBtn.disabled = false;
          }, 2e3);
        } catch (e) {
          syncBtn.textContent = "\u540C\u6B65\u5931\u8D25";
          setTimeout(() => {
            syncBtn.textContent = "\u540C\u6B65\u98DE\u4E66";
            syncBtn.disabled = false;
          }, 2e3);
        }
      }
    });
  }
  updateWeekTitle(element) {
    const weekEnd = new Date(this.currentWeekStart);
    weekEnd.setDate(this.currentWeekStart.getDate() + 6);
    const startMonth = this.currentWeekStart.getMonth() + 1;
    const startDay = this.currentWeekStart.getDate();
    const endMonth = weekEnd.getMonth() + 1;
    const endDay = weekEnd.getDate();
    const year = this.currentWeekStart.getFullYear();
    element.textContent = `${year}\u5E74 ${startMonth}/${startDay} - ${endMonth}/${endDay}`;
  }
  async navigateWeek(offset) {
    this.currentWeekStart.setDate(this.currentWeekStart.getDate() + offset * 7);
    await this.loadEventsForCurrentWeek();
    this.renderCalendar();
    this.updateSummaryBar();
    const titleEl = this.containerEl.querySelector(".week-title");
    if (titleEl) {
      this.updateWeekTitle(titleEl);
    }
  }
  async goToToday() {
    const today = new Date();
    const day = today.getDay();
    const diff = today.getDate() - day + (day === 0 ? -6 : 1);
    this.currentWeekStart = new Date(today);
    this.currentWeekStart.setDate(diff);
    this.currentWeekStart.setHours(0, 0, 0, 0);
    await this.loadEventsForCurrentWeek();
    this.renderCalendar();
    this.updateSummaryBar();
    const titleEl = this.containerEl.querySelector(".week-title");
    if (titleEl) {
      this.updateWeekTitle(titleEl);
    }
  }
  // Load events for the currently displayed week
  async loadEventsForCurrentWeek() {
    if (this.onWeekChange) {
      this.events = await this.onWeekChange(this.currentWeekStart);
    }
  }
  // Get current week start (for external access)
  getCurrentWeekStart() {
    return new Date(this.currentWeekStart);
  }
  // Calculate daily pomodoro stats
  getDailyPomoStats(date) {
    const dayEvents = this.events.filter((event) => {
      const eventDate = new Date(event.start);
      eventDate.setHours(0, 0, 0, 0);
      const targetDate = new Date(date);
      targetDate.setHours(0, 0, 0, 0);
      return eventDate.getTime() === targetDate.getTime();
    });
    let planned = 0;
    let completed = 0;
    for (const event of dayEvents) {
      planned += event.plannedPomodoros || 0;
      completed += event.completedPomodoros || 0;
    }
    return { planned, completed };
  }
  renderCalendar() {
    if (!this.calendarContainer)
      return;
    this.calendarContainer.empty();
    const weekDays = ["\u5468\u4E00", "\u5468\u4E8C", "\u5468\u4E09", "\u5468\u56DB", "\u5468\u4E94", "\u5468\u516D", "\u5468\u65E5"];
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const grid = this.calendarContainer.createDiv({ cls: "time-grid" });
    const headerRow = grid.createDiv({ cls: "time-grid-header" });
    headerRow.createDiv({ cls: "time-column-header" });
    for (let i = 0; i < 7; i++) {
      const date = new Date(this.currentWeekStart);
      date.setDate(this.currentWeekStart.getDate() + i);
      const dayHeader = headerRow.createDiv({ cls: "day-header" });
      const isToday = date.getTime() === today.getTime();
      if (isToday) {
        dayHeader.addClass("today");
      }
      const dayInfo = dayHeader.createDiv({ cls: "day-info" });
      dayInfo.createDiv({ cls: "day-name", text: weekDays[i] });
      dayInfo.createDiv({
        cls: "day-date",
        text: `${date.getMonth() + 1}/${date.getDate()}`
      });
      const pomoStats = this.getDailyPomoStats(date);
      if (pomoStats.planned > 0 || pomoStats.completed > 0) {
        const pieContainer = dayHeader.createDiv({ cls: "pomo-pie-container" });
        this.renderPomoPieChart(pieContainer, pomoStats.completed, pomoStats.planned, isToday);
      }
    }
    const body = grid.createDiv({ cls: "time-grid-body" });
    const timeColumn = body.createDiv({ cls: "time-column" });
    for (let hour = START_HOUR; hour <= END_HOUR; hour++) {
      const slot = timeColumn.createDiv({ cls: "time-slot" });
      slot.style.height = `${HOUR_HEIGHT}px`;
      slot.createSpan({ text: `${String(hour).padStart(2, "0")}:00` });
    }
    const columnsContainer = body.createDiv({ cls: "day-columns-container" });
    this.dayColumnsContainer = columnsContainer;
    for (let i = 0; i < 7; i++) {
      const date = new Date(this.currentWeekStart);
      date.setDate(this.currentWeekStart.getDate() + i);
      const dayColumn = columnsContainer.createDiv({ cls: "day-column" });
      dayColumn.style.height = `${TOTAL_HOURS * HOUR_HEIGHT}px`;
      const isToday = date.getTime() === today.getTime();
      if (isToday) {
        dayColumn.addClass("today");
      }
      for (let hour = START_HOUR; hour < END_HOUR; hour++) {
        const gridLine = dayColumn.createDiv({ cls: "hour-line" });
        gridLine.style.top = `${(hour - START_HOUR) * HOUR_HEIGHT}px`;
      }
      const targetDate = new Date(date);
      targetDate.setHours(0, 0, 0, 0);
      const dayEvents = this.events.filter((event) => {
        const eventDate = new Date(event.start);
        eventDate.setHours(0, 0, 0, 0);
        return eventDate.getTime() === targetDate.getTime();
      });
      dayEvents.sort((a, b) => a.start.getTime() - b.start.getTime());
      const eventLayout = this.calculateEventLayout(dayEvents);
      for (const event of dayEvents) {
        const layout = eventLayout.get(event.id);
        const eventEl = this.createEventElement(event, i, layout);
        dayColumn.appendChild(eventEl);
      }
      if (dayEvents.length === 0) {
        const noEvents = dayColumn.createDiv({ cls: "no-events" });
        noEvents.textContent = "\u70B9\u51FB\u521B\u5EFA\u65E5\u7A0B";
      }
      dayColumn.addEventListener("dblclick", (e) => {
        this.handleDayColumnDoubleClick(e, date, dayColumn);
      });
    }
    this.addCurrentTimeIndicator(columnsContainer);
    this.setupDropZones();
  }
  // Handle double-click on day column to create new event
  handleDayColumnDoubleClick(e, date, dayColumn) {
    const target = e.target;
    if (target.closest(".calendar-event")) {
      return;
    }
    const rect = dayColumn.getBoundingClientRect();
    const relativeY = e.clientY - rect.top;
    const totalMinutes = relativeY / HOUR_HEIGHT * 60 + START_HOUR * 60;
    const snappedMinutes = Math.round(totalMinutes / SNAP_MINUTES) * SNAP_MINUTES;
    const hour = Math.floor(snappedMinutes / 60);
    const minute = snappedMinutes % 60;
    const clampedHour = Math.max(START_HOUR, Math.min(END_HOUR - 1, hour));
    const clampedMinute = minute >= 60 ? 0 : minute;
    const modal = new EventCreateModal(
      this.app,
      date,
      clampedHour,
      clampedMinute,
      async (data) => {
        if (this.onEventCreate) {
          try {
            await this.onEventCreate(data);
            new import_obsidian4.Notice(`\u2705 \u5DF2\u521B\u5EFA: ${data.title}`);
          } catch (error) {
            new import_obsidian4.Notice(`\u521B\u5EFA\u5931\u8D25: ${error.message}`);
          }
        }
      }
    );
    modal.open();
  }
  // Render a small pie chart for pomodoro progress
  renderPomoPieChart(container, completed, planned, isToday) {
    const size = 28;
    const strokeWidth = 4;
    const radius = (size - strokeWidth) / 2;
    const circumference = 2 * Math.PI * radius;
    const percentage = planned > 0 ? completed / planned * 100 : 0;
    const dashOffset = circumference - percentage / 100 * circumference;
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("width", String(size));
    svg.setAttribute("height", String(size));
    svg.setAttribute("class", "pomo-pie");
    const bgCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    bgCircle.setAttribute("cx", String(size / 2));
    bgCircle.setAttribute("cy", String(size / 2));
    bgCircle.setAttribute("r", String(radius));
    bgCircle.setAttribute("fill", "none");
    bgCircle.setAttribute("stroke", isToday ? "rgba(255,255,255,0.3)" : "var(--background-modifier-border)");
    bgCircle.setAttribute("stroke-width", String(strokeWidth));
    svg.appendChild(bgCircle);
    if (percentage > 0) {
      const progressCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      progressCircle.setAttribute("cx", String(size / 2));
      progressCircle.setAttribute("cy", String(size / 2));
      progressCircle.setAttribute("r", String(radius));
      progressCircle.setAttribute("fill", "none");
      progressCircle.setAttribute("stroke", "#22c55e");
      progressCircle.setAttribute("stroke-width", String(strokeWidth));
      progressCircle.setAttribute("stroke-dasharray", String(circumference));
      progressCircle.setAttribute("stroke-dashoffset", String(dashOffset));
      progressCircle.setAttribute("stroke-linecap", "round");
      progressCircle.setAttribute("transform", `rotate(-90 ${size / 2} ${size / 2})`);
      svg.appendChild(progressCircle);
    }
    container.appendChild(svg);
    const label = container.createDiv({ cls: "pomo-pie-label" });
    label.textContent = `${completed}/${planned}`;
  }
  // Calculate layout for overlapping events
  // Returns a map of event ID -> { column: number, totalColumns: number }
  calculateEventLayout(events) {
    const layout = /* @__PURE__ */ new Map();
    if (events.length === 0)
      return layout;
    const groups = [];
    for (const event of events) {
      let addedToGroup = false;
      for (const group of groups) {
        const overlaps = group.some((e) => this.eventsOverlap(e, event));
        if (overlaps) {
          group.push(event);
          addedToGroup = true;
          break;
        }
      }
      if (!addedToGroup) {
        groups.push([event]);
      }
    }
    let merged = true;
    while (merged) {
      merged = false;
      for (let i = 0; i < groups.length; i++) {
        for (let j = i + 1; j < groups.length; j++) {
          const shouldMerge = groups[i].some(
            (ei) => groups[j].some((ej) => this.eventsOverlap(ei, ej))
          );
          if (shouldMerge) {
            groups[i].push(...groups[j]);
            groups.splice(j, 1);
            merged = true;
            break;
          }
        }
        if (merged)
          break;
      }
    }
    for (const group of groups) {
      if (group.length === 1) {
        layout.set(group[0].id, { column: 0, totalColumns: 1 });
        continue;
      }
      group.sort((a, b) => a.start.getTime() - b.start.getTime());
      const columns = [];
      for (const event of group) {
        let placed = false;
        for (let col = 0; col < columns.length; col++) {
          const colEvents = columns[col];
          const overlapsInCol = colEvents.some((e) => this.eventsOverlap(e, event));
          if (!overlapsInCol) {
            colEvents.push(event);
            layout.set(event.id, { column: col, totalColumns: 0 });
            placed = true;
            break;
          }
        }
        if (!placed) {
          columns.push([event]);
          layout.set(event.id, { column: columns.length - 1, totalColumns: 0 });
        }
      }
      const totalCols = columns.length;
      for (const event of group) {
        const l = layout.get(event.id);
        l.totalColumns = totalCols;
      }
    }
    return layout;
  }
  // Check if two events overlap in time
  eventsOverlap(a, b) {
    return a.start < b.end && b.start < a.end;
  }
  createEventElement(event, dayIndex, layout) {
    const eventEl = document.createElement("div");
    eventEl.className = "calendar-event";
    eventEl.setAttribute("data-event-id", event.id);
    eventEl.setAttribute("data-day-index", String(dayIndex));
    const startHour = event.start.getHours();
    const startMinute = event.start.getMinutes();
    const endHour = event.end.getHours();
    const endMinute = event.end.getMinutes();
    const startOffset = startHour - START_HOUR + startMinute / 60;
    const endOffset = endHour - START_HOUR + endMinute / 60;
    const duration = endOffset - startOffset;
    const top = Math.max(0, startOffset * HOUR_HEIGHT);
    const height = Math.max(30, duration * HOUR_HEIGHT - 2);
    eventEl.style.top = `${top}px`;
    eventEl.style.height = `${height}px`;
    if (layout && layout.totalColumns > 1) {
      const widthPercent = 100 / layout.totalColumns;
      const leftPercent = layout.column * widthPercent;
      eventEl.style.width = `calc(${widthPercent}% - 4px)`;
      eventEl.style.left = `calc(${leftPercent}% + 2px)`;
    }
    eventEl.style.backgroundColor = CATEGORY_COLORS[event.category];
    eventEl.style.borderLeftColor = this.darkenColor(CATEGORY_COLORS[event.category], 20);
    const titleEl = eventEl.createDiv({ cls: "event-title" });
    titleEl.textContent = event.title;
    const timeEl = eventEl.createDiv({ cls: "event-time" });
    timeEl.textContent = `${this.formatTime(event.start)} - ${this.formatTime(event.end)}`;
    if ((event.plannedPomodoros || event.completedPomodoros) && height > 50) {
      const pomoEl = eventEl.createDiv({ cls: "event-pomodoro" });
      const completed = event.completedPomodoros || 0;
      const planned = event.plannedPomodoros || 0;
      let pomoText = "";
      for (let p = 0; p < Math.min(planned, 5); p++) {
        pomoText += p < completed ? "\u{1F345}" : "\u26AA";
      }
      if (planned > 5) {
        pomoText += `+${planned - 5}`;
      }
      if (planned > 0) {
        pomoText += ` ${completed}/${planned}`;
      }
      pomoEl.createSpan({ text: pomoText });
    }
    const dragHandle = eventEl.createDiv({ cls: "event-drag-handle" });
    dragHandle.innerHTML = "\u22EE\u22EE";
    eventEl.addEventListener("mousedown", (e) => {
      if (e.button !== 0)
        return;
      e.preventDefault();
      this.startDrag(e, event, eventEl, dayIndex);
    });
    eventEl.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.showEventMenu(e, event);
    });
    return eventEl;
  }
  // ========== DRAG AND DROP FUNCTIONALITY ==========
  startDrag(e, event, eventEl, dayIndex) {
    const top = parseFloat(eventEl.style.top) || 0;
    this.dragState = {
      event,
      eventEl,
      startY: e.clientY,
      startX: e.clientX,
      originalTop: top,
      originalDayIndex: dayIndex,
      currentDayIndex: dayIndex,
      isDragging: false
    };
    document.addEventListener("mousemove", this.handleDragMove);
    document.addEventListener("mouseup", this.handleDragEnd);
  }
  updateDragTimeDisplay() {
    if (!this.dragState)
      return;
    const newTop = parseFloat(this.dragState.eventEl.style.top) || 0;
    const hoursFromTop = newTop / HOUR_HEIGHT;
    const newStartHour = Math.floor(START_HOUR + hoursFromTop);
    const newStartMinute = Math.round(hoursFromTop % 1 * 60 / SNAP_MINUTES) * SNAP_MINUTES;
    const durationMs = this.dragState.event.end.getTime() - this.dragState.event.start.getTime();
    const durationMin = durationMs / 6e4;
    const endTotalMin = newStartHour * 60 + newStartMinute + durationMin;
    const newEndHour = Math.floor(endTotalMin / 60);
    const newEndMinute = endTotalMin % 60;
    const timeEl = this.dragState.eventEl.querySelector(".event-time");
    if (timeEl) {
      const startStr = `${String(newStartHour).padStart(2, "0")}:${String(newStartMinute).padStart(2, "0")}`;
      const endStr = `${String(newEndHour).padStart(2, "0")}:${String(newEndMinute).padStart(2, "0")}`;
      timeEl.textContent = `${startStr} - ${endStr}`;
    }
  }
  // ========== CONTEXT MENU ==========
  // Show context menu for event
  showEventMenu(e, event) {
    const menu = new import_obsidian4.Menu();
    menu.addItem((item) => {
      item.setTitle(`\u{1F4CC} ${event.title}`).setDisabled(true);
    });
    menu.addItem((item) => {
      item.setTitle(`\u23F1\uFE0F ${this.formatTime(event.start)} - ${this.formatTime(event.end)}`).setDisabled(true);
    });
    if (event.plannedPomodoros) {
      menu.addItem((item) => {
        item.setTitle(`\u{1F3AF} \u8BA1\u5212 ${event.plannedPomodoros} \u4E2A\u756A\u8304\u949F`).setDisabled(true);
      });
    }
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("\u{1F345} \u5F00\u59CB\u756A\u8304\u949F").setIcon("timer").onClick(() => {
        if (this.onStartPomodoro) {
          this.onStartPomodoro(event);
        }
      });
    });
    if (event.filePath) {
      menu.addItem((item) => {
        item.setTitle("\u{1F4DD} \u6253\u5F00\u65E5\u62A5").setIcon("file-text").onClick(() => {
          if (this.onEventClick) {
            this.onEventClick(event);
          }
        });
      });
    }
    if (event.source === "local") {
      menu.addSeparator();
      menu.addItem((item) => {
        item.setTitle("\u{1F5D1}\uFE0F \u5220\u9664\u65E5\u7A0B").setIcon("trash").onClick(async () => {
          if (this.onEventDelete) {
            try {
              await this.onEventDelete(event);
              new import_obsidian4.Notice(`\u{1F5D1}\uFE0F \u5DF2\u5220\u9664: ${event.title}`);
            } catch (error) {
              new import_obsidian4.Notice(`\u5220\u9664\u5931\u8D25: ${error.message}`);
            }
          }
        });
      });
    }
    menu.showAtMouseEvent(e);
  }
  addCurrentTimeIndicator(container) {
    const now = new Date();
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const weekEnd = new Date(this.currentWeekStart);
    weekEnd.setDate(this.currentWeekStart.getDate() + 6);
    weekEnd.setHours(23, 59, 59, 999);
    if (today < this.currentWeekStart || today > weekEnd) {
      return;
    }
    const dayIndex = Math.floor((today.getTime() - this.currentWeekStart.getTime()) / (24 * 60 * 60 * 1e3));
    if (dayIndex < 0 || dayIndex > 6)
      return;
    const currentHour = now.getHours();
    const currentMinute = now.getMinutes();
    if (currentHour < START_HOUR || currentHour >= END_HOUR)
      return;
    const top = (currentHour - START_HOUR + currentMinute / 60) * HOUR_HEIGHT;
    const indicator = container.createDiv({ cls: "current-time-indicator" });
    indicator.style.top = `${top}px`;
    const dayColumns = container.querySelectorAll(".day-column");
    if (dayColumns[dayIndex]) {
      const dayColumn = dayColumns[dayIndex];
      const rect = dayColumn.getBoundingClientRect();
      const containerRect = container.getBoundingClientRect();
      indicator.style.left = `${rect.left - containerRect.left}px`;
      indicator.style.width = `${rect.width}px`;
    }
  }
  darkenColor(color, percent) {
    const num = parseInt(color.replace("#", ""), 16);
    const amt = Math.round(2.55 * percent);
    const R = Math.max(0, (num >> 16) - amt);
    const G = Math.max(0, (num >> 8 & 255) - amt);
    const B = Math.max(0, (num & 255) - amt);
    return `#${(16777216 + R * 65536 + G * 256 + B).toString(16).slice(1)}`;
  }
  formatTime(date) {
    return `${String(date.getHours()).padStart(2, "0")}:${String(date.getMinutes()).padStart(2, "0")}`;
  }
  setEvents(events) {
    this.events = events;
    this.renderCalendar();
    this.updateSummaryBar();
  }
  // Update bottom summary bar
  async updateSummaryBar() {
    if (!this.summaryContainer)
      return;
    this.summaryContainer.empty();
    let totalPlanned = 0;
    let totalCompleted = 0;
    const byCategory = {
      ["focus" /* FOCUS */]: 0,
      ["meeting" /* MEETING */]: 0,
      ["personal" /* PERSONAL */]: 0,
      ["rest" /* REST */]: 0,
      ["admin" /* ADMIN */]: 0
    };
    for (const event of this.events) {
      totalPlanned += event.plannedPomodoros || 0;
      totalCompleted += event.completedPomodoros || 0;
      const durationMs = event.end.getTime() - event.start.getTime();
      const durationMin = Math.round(durationMs / 6e4);
      byCategory[event.category] += durationMin;
    }
    const pomoSection = this.summaryContainer.createDiv({ cls: "summary-section pomo-section" });
    pomoSection.createSpan({ cls: "summary-icon", text: "\u{1F345}" });
    pomoSection.createSpan({ cls: "summary-label", text: "\u672C\u5468\u756A\u8304" });
    pomoSection.createSpan({ cls: "summary-value", text: `${totalCompleted}/${totalPlanned}` });
    const progressBar = pomoSection.createDiv({ cls: "summary-progress" });
    const progressFill = progressBar.createDiv({ cls: "summary-progress-fill" });
    const progressPercent = totalPlanned > 0 ? totalCompleted / totalPlanned * 100 : 0;
    progressFill.style.width = `${progressPercent}%`;
    this.summaryContainer.createDiv({ cls: "summary-divider" });
    const categorySection = this.summaryContainer.createDiv({ cls: "summary-section category-section" });
    for (const category of Object.values(EventCategory)) {
      const minutes = byCategory[category];
      if (minutes > 0) {
        const item = categorySection.createDiv({ cls: "category-item" });
        const colorDot = item.createDiv({ cls: "category-dot" });
        colorDot.style.backgroundColor = CATEGORY_COLORS[category];
        const hours = (minutes / 60).toFixed(1);
        item.createSpan({ text: `${CATEGORY_LABELS[category]} ${hours}h` });
      }
    }
    this.summaryContainer.createDiv({ cls: "summary-divider" });
    const legendSection = this.summaryContainer.createDiv({ cls: "summary-section legend-section" });
    for (const category of Object.values(EventCategory)) {
      const item = legendSection.createDiv({ cls: "legend-item" });
      const colorDot = item.createDiv({ cls: "legend-dot" });
      colorDot.style.backgroundColor = CATEGORY_COLORS[category];
      item.createSpan({ text: CATEGORY_LABELS[category] });
    }
  }
  async onClose() {
  }
  // ========== TASK PANEL ==========
  // Load tasks for the panel
  async loadTasksForPanel() {
    if (this.onGetTasks) {
      this.taskPanelData = await this.onGetTasks(this.currentWeekStart);
    }
  }
  // Render the task panel
  renderTaskPanel() {
    if (!this.taskPanel)
      return;
    this.taskPanel.empty();
    const header = this.taskPanel.createDiv({ cls: "task-panel-header" });
    header.createSpan({ text: "\u{1F4CB} \u5F85\u529E\u4EFB\u52A1" });
    const refreshBtn = header.createEl("button", { cls: "task-panel-refresh", text: "\u21BB" });
    refreshBtn.addEventListener("click", async () => {
      await this.loadTasksForPanel();
      this.renderTaskPanel();
    });
    if (!this.taskPanelData) {
      this.taskPanel.createDiv({ cls: "task-panel-empty", text: "\u52A0\u8F7D\u4E2D..." });
      return;
    }
    const { today, thisWeek, overdue } = this.taskPanelData;
    if (overdue.length > 0) {
      this.renderTaskSection(this.taskPanel, "\u{1F534} \u5DF2\u8FC7\u671F", overdue, "overdue");
    }
    if (today.length > 0) {
      this.renderTaskSection(this.taskPanel, "\u{1F7E0} \u4ECA\u65E5 Due", today, "today");
    }
    if (thisWeek.length > 0) {
      this.renderTaskSection(this.taskPanel, "\u{1F7E1} \u672C\u5468 Due", thisWeek, "week");
    }
    if (overdue.length === 0 && today.length === 0 && thisWeek.length === 0) {
      const emptyDiv = this.taskPanel.createDiv({ cls: "task-panel-empty" });
      emptyDiv.createSpan({ text: "\u6682\u65E0\u5F85\u529E\u4EFB\u52A1" });
      emptyDiv.createEl("br");
      emptyDiv.createSpan({ cls: "task-panel-hint", text: "\u4EFB\u52A1\u6765\u6E90: Inbox.md, Projects/, Areas/" });
    }
    const hint = this.taskPanel.createDiv({ cls: "task-panel-hint" });
    hint.textContent = "\u{1F4A1} \u62D6\u62FD\u4EFB\u52A1\u5230\u65E5\u5386\u521B\u5EFA\u65E5\u7A0B";
  }
  // Render a section of tasks
  renderTaskSection(container, title, tasks, sectionType) {
    const section = container.createDiv({ cls: `task-panel-section ${sectionType}` });
    const header = section.createDiv({ cls: "task-panel-section-header" });
    header.createSpan({ text: title });
    header.createSpan({ cls: "task-count", text: `(${tasks.length})` });
    const taskList = section.createDiv({ cls: "task-list" });
    for (const task of tasks) {
      const taskCard = this.createTaskCard(task);
      taskList.appendChild(taskCard);
    }
  }
  // Create a draggable task card
  createTaskCard(task) {
    const card = document.createElement("div");
    card.className = "task-card";
    card.setAttribute("draggable", "true");
    card.addClass(`priority-${task.priority}`);
    const titleEl = card.createDiv({ cls: "task-card-title" });
    if (task.priority === "highest") {
      titleEl.createSpan({ cls: "task-priority", text: "\u23EB " });
    } else if (task.priority === "high") {
      titleEl.createSpan({ cls: "task-priority", text: "\u{1F53A} " });
    }
    titleEl.createSpan({ text: task.title });
    const metaEl = card.createDiv({ cls: "task-meta" });
    if (task.pomodoros > 0) {
      metaEl.createSpan({ cls: "task-pomo", text: `${task.pomodoros}\u{1F345}` });
    }
    if (task.dueDate) {
      const dateStr = `${task.dueDate.getMonth() + 1}/${task.dueDate.getDate()}`;
      metaEl.createSpan({ cls: "task-due", text: `\u{1F4C5} ${dateStr}` });
    }
    if (task.tags.length > 0) {
      const tagsStr = task.tags.slice(0, 2).map((t) => `#${t}`).join(" ");
      metaEl.createSpan({ cls: "task-tags", text: tagsStr });
    }
    card.addEventListener("click", (e) => {
      if (e.detail === 1) {
        this.openTaskSource(task);
      }
    });
    card.addEventListener("dragstart", (e) => {
      var _a;
      card.addClass("dragging");
      (_a = e.dataTransfer) == null ? void 0 : _a.setData("application/json", JSON.stringify(task));
      e.dataTransfer.effectAllowed = "copy";
    });
    card.addEventListener("dragend", () => {
      card.removeClass("dragging");
    });
    return card;
  }
  // Set up drop zones on day columns
  setupDropZones() {
    if (!this.dayColumnsContainer)
      return;
    const dayColumns = this.dayColumnsContainer.querySelectorAll(".day-column");
    dayColumns.forEach((col, index) => {
      const column = col;
      column.addEventListener("dragover", (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = "copy";
        column.addClass("drop-target");
      });
      column.addEventListener("dragleave", () => {
        column.removeClass("drop-target");
      });
      column.addEventListener("drop", (e) => {
        var _a;
        e.preventDefault();
        column.removeClass("drop-target");
        const taskData = (_a = e.dataTransfer) == null ? void 0 : _a.getData("application/json");
        if (taskData) {
          try {
            const task = JSON.parse(taskData);
            const date = new Date(this.currentWeekStart);
            date.setDate(date.getDate() + index);
            this.handleTaskDrop(e, task, date, column);
          } catch (err) {
            console.error("Failed to parse dropped task:", err);
          }
        }
      });
    });
  }
  // Handle dropping a task onto the calendar
  handleTaskDrop(e, task, date, dayColumn) {
    const rect = dayColumn.getBoundingClientRect();
    const relativeY = e.clientY - rect.top;
    const totalMinutes = relativeY / HOUR_HEIGHT * 60 + START_HOUR * 60;
    const snappedMinutes = Math.round(totalMinutes / SNAP_MINUTES) * SNAP_MINUTES;
    const hour = Math.floor(snappedMinutes / 60);
    const minute = snappedMinutes % 60;
    const clampedHour = Math.max(START_HOUR, Math.min(END_HOUR - 1, hour));
    const clampedMinute = minute >= 60 ? 0 : minute;
    const durationMinutes = task.pomodoros > 0 ? task.pomodoros * 25 : 60;
    const startDate = new Date(date);
    startDate.setHours(clampedHour, clampedMinute, 0, 0);
    const endDate = new Date(startDate.getTime() + durationMinutes * 60 * 1e3);
    if (endDate.getHours() > END_HOUR || endDate.getHours() === END_HOUR && endDate.getMinutes() > 0) {
      endDate.setHours(END_HOUR, 0, 0, 0);
    }
    let category = "focus" /* FOCUS */;
    if (this.onTaskInferCategory) {
      category = this.onTaskInferCategory(task);
    }
    const eventData = {
      title: task.title,
      category,
      start: startDate,
      end: endDate,
      taskSourcePath: task.sourcePath,
      taskLineNumber: task.lineNumber
    };
    if (this.onEventCreate) {
      this.onEventCreate(eventData).then(() => {
        new import_obsidian4.Notice(`\u2705 \u5DF2\u521B\u5EFA\u65E5\u7A0B: ${task.title}`);
      }).catch((error) => {
        new import_obsidian4.Notice(`\u521B\u5EFA\u5931\u8D25: ${error.message}`);
      });
    }
  }
  // Refresh task panel (can be called externally)
  async refreshTaskPanel() {
    await this.loadTasksForPanel();
    this.renderTaskPanel();
  }
  // Open task source file at specific line
  openTaskSource(task) {
    if (!task.sourcePath)
      return;
    const file = this.app.vault.getAbstractFileByPath(task.sourcePath);
    if (file) {
      this.app.workspace.openLinkText("", task.sourcePath).then(() => {
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian4.ItemView);
        if (activeView) {
          const editor = activeView.editor;
          if (editor) {
            const line = task.lineNumber - 1;
            editor.setCursor({ line, ch: 0 });
            editor.scrollIntoView({ from: { line, ch: 0 }, to: { line, ch: 0 } }, true);
          }
        }
      });
    }
  }
};

// src/settingsTab.ts
var import_obsidian5 = require("obsidian");
var AuthCodeModal = class extends import_obsidian5.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.code = "";
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "\u8F93\u5165\u98DE\u4E66\u6388\u6743\u7801" });
    contentEl.createEl("p", {
      text: "\u8BF7\u5728\u6D4F\u89C8\u5668\u4E2D\u5B8C\u6210\u98DE\u4E66\u767B\u5F55\u540E\uFF0C\u4ECE\u8DF3\u8F6C\u7684 URL \u4E2D\u590D\u5236 code \u53C2\u6570\u7684\u503C\u3002",
      cls: "setting-item-description"
    });
    contentEl.createEl("p", {
      text: "\u4F8B\u5982: http://localhost:3000/callback?code=abc123&state=xxx",
      cls: "setting-item-description"
    });
    contentEl.createEl("p", {
      text: "\u590D\u5236 abc123 \u8FD9\u90E8\u5206\uFF08code= \u540E\u9762\u5230 & \u4E4B\u524D\u7684\u5185\u5BB9\uFF09",
      cls: "setting-item-description"
    });
    new import_obsidian5.Setting(contentEl).setName("\u6388\u6743\u7801 (code)").addText((text) => {
      text.setPlaceholder("\u7C98\u8D34\u6388\u6743\u7801...").onChange((value) => {
        this.code = value.trim();
      });
      text.inputEl.style.width = "300px";
    });
    new import_obsidian5.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("\u53D6\u6D88").onClick(() => {
        this.close();
      })
    ).addButton(
      (btn) => btn.setButtonText("\u786E\u8BA4").setCta().onClick(() => {
        if (this.code) {
          this.onSubmit(this.code);
          this.close();
        }
      })
    );
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var FocusPlannerSettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Focus Planner \u8BBE\u7F6E" });
    containerEl.createEl("h3", { text: "\u98DE\u4E66\u65E5\u5386\u540C\u6B65" });
    new import_obsidian5.Setting(containerEl).setName("\u542F\u7528\u98DE\u4E66\u540C\u6B65").setDesc("\u4ECE\u98DE\u4E66\u65E5\u5386\u81EA\u52A8\u540C\u6B65\u65E5\u7A0B\u5230 Obsidian").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.feishu.syncEnabled).onChange(async (value) => {
        this.plugin.settings.feishu.syncEnabled = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.feishu.syncEnabled) {
      new import_obsidian5.Setting(containerEl).setName("\u4F7F\u7528 CalDAV \u540C\u6B65\uFF08\u63A8\u8350\uFF09").setDesc("CalDAV \u80FD\u6B63\u786E\u5904\u7406\u91CD\u590D\u65E5\u7A0B\uFF0C\u9700\u8981\u5728\u98DE\u4E66\u8BBE\u7F6E\u4E2D\u751F\u6210 CalDAV \u5BC6\u7801").addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.feishu.useCalDav).onChange(async (value) => {
          this.plugin.settings.feishu.useCalDav = value;
          await this.plugin.saveSettings();
          this.display();
        })
      );
      new import_obsidian5.Setting(containerEl).setName("\u540C\u6B65\u95F4\u9694").setDesc("\u81EA\u52A8\u540C\u6B65\u7684\u95F4\u9694\u65F6\u95F4\uFF08\u5206\u949F\uFF09").addSlider(
        (slider) => slider.setLimits(5, 60, 5).setValue(this.plugin.settings.feishu.syncInterval).setDynamicTooltip().onChange(async (value) => {
          this.plugin.settings.feishu.syncInterval = value;
          await this.plugin.saveSettings();
        })
      );
      if (this.plugin.settings.feishu.useCalDav) {
        containerEl.createEl("h4", { text: "CalDAV \u914D\u7F6E" });
        containerEl.createEl("p", {
          text: "\u5728\u98DE\u4E66\u684C\u9762\u7AEF\uFF1A\u8BBE\u7F6E \u2192 \u65E5\u5386 \u2192 CalDAV \u540C\u6B65 \u2192 \u9009\u62E9\u8BBE\u5907 \u2192 \u751F\u6210",
          cls: "setting-item-description"
        });
        new import_obsidian5.Setting(containerEl).setName("CalDAV \u7528\u6237\u540D").setDesc("\u98DE\u4E66\u751F\u6210\u7684 CalDAV \u7528\u6237\u540D").addText(
          (text) => text.setPlaceholder("\u8F93\u5165\u7528\u6237\u540D...").setValue(this.plugin.settings.feishu.caldavUsername || "").onChange(async (value) => {
            this.plugin.settings.feishu.caldavUsername = value;
            await this.plugin.saveSettings();
          })
        );
        new import_obsidian5.Setting(containerEl).setName("CalDAV \u5BC6\u7801").setDesc("\u98DE\u4E66\u751F\u6210\u7684 CalDAV \u5BC6\u7801").addText((text) => {
          text.setPlaceholder("\u8F93\u5165\u5BC6\u7801...").setValue(this.plugin.settings.feishu.caldavPassword || "").onChange(async (value) => {
            this.plugin.settings.feishu.caldavPassword = value;
            await this.plugin.saveSettings();
          });
          text.inputEl.type = "password";
        });
        const caldavStatus = this.plugin.settings.feishu.caldavUsername && this.plugin.settings.feishu.caldavPassword;
        new import_obsidian5.Setting(containerEl).setName("\u72B6\u6001").setDesc(caldavStatus ? "\u2713 CalDAV \u5DF2\u914D\u7F6E" : "\u26A0 \u8BF7\u586B\u5199\u7528\u6237\u540D\u548C\u5BC6\u7801");
      } else {
        containerEl.createEl("h4", { text: "Open API \u914D\u7F6E" });
        new import_obsidian5.Setting(containerEl).setName("App ID").setDesc("\u98DE\u4E66\u5F00\u653E\u5E73\u53F0\u5E94\u7528\u7684 App ID").addText(
          (text) => text.setPlaceholder("cli_xxxxx").setValue(this.plugin.settings.feishu.appId).onChange(async (value) => {
            this.plugin.settings.feishu.appId = value;
            await this.plugin.saveSettings();
          })
        );
        new import_obsidian5.Setting(containerEl).setName("App Secret").setDesc("\u98DE\u4E66\u5F00\u653E\u5E73\u53F0\u5E94\u7528\u7684 App Secret").addText(
          (text) => text.setPlaceholder("xxxxx").setValue(this.plugin.settings.feishu.appSecret).onChange(async (value) => {
            this.plugin.settings.feishu.appSecret = value;
            await this.plugin.saveSettings();
          })
        );
        const loginSetting = new import_obsidian5.Setting(containerEl).setName("\u98DE\u4E66\u767B\u5F55").setDesc(
          this.plugin.settings.feishu.accessToken ? "\u5DF2\u767B\u5F55 \u2713" : "\u70B9\u51FB\u767B\u5F55\u98DE\u4E66\u8D26\u53F7\u4EE5\u540C\u6B65\u65E5\u5386"
        ).addButton(
          (button) => button.setButtonText("1. \u6253\u5F00\u6388\u6743\u9875\u9762").onClick(async () => {
            await this.plugin.loginFeishu();
          })
        ).addButton(
          (button) => button.setButtonText("2. \u8F93\u5165\u6388\u6743\u7801").setCta().onClick(() => {
            new AuthCodeModal(this.app, async (code) => {
              await this.plugin.handleAuthCode(code);
              this.display();
            }).open();
          })
        );
        if (this.plugin.settings.feishu.accessToken) {
          loginSetting.addButton(
            (button) => button.setButtonText("\u9000\u51FA\u767B\u5F55").setWarning().onClick(async () => {
              this.plugin.settings.feishu.accessToken = "";
              this.plugin.settings.feishu.refreshToken = "";
              this.plugin.settings.feishu.tokenExpiry = 0;
              this.plugin.settings.feishu.calendarId = "";
              await this.plugin.saveSettings();
              this.display();
            })
          );
        }
      }
    }
    containerEl.createEl("h3", { text: "\u65E5\u62A5\u8BBE\u7F6E" });
    new import_obsidian5.Setting(containerEl).setName("\u65E5\u62A5\u8DEF\u5F84\u683C\u5F0F").setDesc("\u65E5\u62A5\u6587\u4EF6\u7684\u8DEF\u5F84\u683C\u5F0F\uFF0C\u652F\u6301 YYYY, MM, DD \u53D8\u91CF").addText(
      (text) => text.setPlaceholder("0. PeriodicNotes/YYYY/Daily/MM/YYYY-MM-DD.md").setValue(this.plugin.settings.dailyNotePath).onChange(async (value) => {
        this.plugin.settings.dailyNotePath = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "\u756A\u8304\u949F\u8BBE\u7F6E" });
    new import_obsidian5.Setting(containerEl).setName("\u756A\u8304\u949F\u65F6\u957F").setDesc("\u6BCF\u4E2A\u756A\u8304\u949F\u7684\u5206\u949F\u6570").addSlider(
      (slider) => slider.setLimits(15, 45, 5).setValue(this.plugin.settings.pomodoroMinutes).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.pomodoroMinutes = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "\u4E8B\u4EF6\u5206\u7C7B\u5173\u952E\u8BCD" });
    containerEl.createEl("p", {
      text: "\u6839\u636E\u4E8B\u4EF6\u6807\u9898\u4E2D\u7684\u5173\u952E\u8BCD\u81EA\u52A8\u5206\u7C7B\uFF0C\u591A\u4E2A\u5173\u952E\u8BCD\u7528\u9017\u53F7\u5206\u9694",
      cls: "setting-item-description"
    });
    for (const category of Object.values(EventCategory)) {
      new import_obsidian5.Setting(containerEl).setName(CATEGORY_LABELS[category]).addTextArea(
        (text) => text.setPlaceholder("\u5173\u952E\u8BCD1, \u5173\u952E\u8BCD2, ...").setValue(this.plugin.settings.categoryKeywords[category].join(", ")).onChange(async (value) => {
          this.plugin.settings.categoryKeywords[category] = value.split(",").map((s) => s.trim()).filter((s) => s.length > 0);
          await this.plugin.saveSettings();
        })
      );
    }
    containerEl.createEl("h3", { text: "\u663E\u793A\u8BBE\u7F6E" });
    new import_obsidian5.Setting(containerEl).setName("\u663E\u793A\u7EDF\u8BA1\u9762\u677F").setDesc("\u5728\u65E5\u5386\u89C6\u56FE\u65C1\u8FB9\u663E\u793A\u5468\u7EDF\u8BA1\u6570\u636E").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showStatsPanel).onChange(async (value) => {
        this.plugin.settings.showStatsPanel = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/taskParser.ts
var import_obsidian6 = require("obsidian");
var STATUS_MAP = {
  " ": "todo",
  "x": "done",
  "X": "done",
  "/": "in_progress",
  "-": "cancelled",
  ">": "deferred"
};
var TaskParser = class {
  constructor(app, taskSources) {
    this.app = app;
    this.taskSources = taskSources || [
      "Inbox.md",
      "1. Projects/",
      "2. Areas/",
      "3. Resources/"
    ];
  }
  /**
   * Parse a single task line
   */
  parseTaskLine(line, sourcePath, lineNumber) {
    var _a;
    const taskMatch = line.match(/^[\s]*[-*]\s*\[(.)\]\s*(.+)$/);
    if (!taskMatch)
      return null;
    const statusChar = taskMatch[1];
    const content = taskMatch[2];
    const status = STATUS_MAP[statusChar] || "todo";
    if (status === "done" || status === "cancelled")
      return null;
    let priority = "normal";
    if (content.includes("\u23EB"))
      priority = "highest";
    else if (content.includes("\u{1F53A}"))
      priority = "high";
    else if (content.includes("\u{1F53D}"))
      priority = "low";
    let dueDate = null;
    const dueDateMatches = content.match(/üìÖ\s*(\d{4}-\d{2}-\d{2})/g);
    if (dueDateMatches && dueDateMatches.length > 0) {
      const lastMatch = dueDateMatches[dueDateMatches.length - 1];
      const dateStr = (_a = lastMatch.match(/üìÖ\s*(\d{4}-\d{2}-\d{2})/)) == null ? void 0 : _a[1];
      if (dateStr) {
        dueDate = new Date(dateStr);
        dueDate.setHours(23, 59, 59);
      }
    }
    let scheduledDate = null;
    const scheduledMatch = content.match(/‚è≥\s*(\d{4}-\d{2}-\d{2})/);
    if (scheduledMatch) {
      scheduledDate = new Date(scheduledMatch[1]);
    }
    let pomodoros = 0;
    const pomoMatch = content.match(/\[pomo::\s*(\d+)\]/);
    if (pomoMatch) {
      pomodoros = parseInt(pomoMatch[1], 10);
    } else {
      const tomatoMatch = content.match(/(\d+)üçÖ/);
      if (tomatoMatch) {
        pomodoros = parseInt(tomatoMatch[1], 10);
      }
    }
    let pomodorosDone = 0;
    const doneMatch = content.match(/\[done::\s*(\d+)\]/);
    if (doneMatch) {
      pomodorosDone = parseInt(doneMatch[1], 10);
    }
    const tags = [];
    const tagMatches = content.matchAll(/#([^\s#\[\]]+)/g);
    for (const match of tagMatches) {
      tags.push(match[1]);
    }
    let title = content.replace(/‚è´|üî∫|üîΩ/g, "").replace(/üìÖ\s*\d{4}-\d{2}-\d{2}/g, "").replace(/‚è≥\s*\d{4}-\d{2}-\d{2}/g, "").replace(/‚úÖ\s*\d{4}-\d{2}-\d{2}/g, "").replace(/\[pomo::\s*\d+\]/g, "").replace(/\[done::\s*\d+\]/g, "").replace(/\d+üçÖ/g, "").replace(/#[^\s#\[\]]+/g, "").replace(/\[\[[^\]]+\]\]/g, (match) => {
      return match.slice(2, -2).split("|").pop() || "";
    }).trim();
    title = title.replace(/\s+/g, " ").trim();
    if (!title)
      return null;
    return {
      raw: line,
      title,
      status,
      priority,
      dueDate,
      scheduledDate,
      pomodoros,
      pomodorosDone,
      tags,
      sourcePath,
      lineNumber
    };
  }
  /**
   * Parse all tasks from a file
   */
  async parseFile(file) {
    const tasks = [];
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    for (let i = 0; i < lines.length; i++) {
      const task = this.parseTaskLine(lines[i], file.path, i + 1);
      if (task) {
        tasks.push(task);
      }
    }
    return tasks;
  }
  /**
   * Get all files from task sources
   */
  getSourceFiles() {
    const files = [];
    for (const source of this.taskSources) {
      if (source.endsWith("/")) {
        const folder = this.app.vault.getAbstractFileByPath(source.slice(0, -1));
        if (folder instanceof import_obsidian6.TFolder) {
          this.collectFilesFromFolder(folder, files);
        }
      } else {
        const file = this.app.vault.getAbstractFileByPath(source);
        if (file instanceof import_obsidian6.TFile && file.extension === "md") {
          files.push(file);
        }
      }
    }
    return files;
  }
  /**
   * Recursively collect markdown files from a folder
   */
  collectFilesFromFolder(folder, files) {
    for (const child of folder.children) {
      if (child instanceof import_obsidian6.TFile && child.extension === "md") {
        if (!child.path.toLowerCase().includes("template")) {
          files.push(child);
        }
      } else if (child instanceof import_obsidian6.TFolder) {
        this.collectFilesFromFolder(child, files);
      }
    }
  }
  /**
   * Parse all tasks from configured sources
   */
  async parseAllTasks() {
    const allTasks = [];
    const files = this.getSourceFiles();
    for (const file of files) {
      const tasks = await this.parseFile(file);
      allTasks.push(...tasks);
    }
    return allTasks.sort((a, b) => {
      const priorityOrder = { highest: 0, high: 1, normal: 2, low: 3 };
      const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];
      if (priorityDiff !== 0)
        return priorityDiff;
      if (a.dueDate && b.dueDate) {
        return a.dueDate.getTime() - b.dueDate.getTime();
      }
      if (a.dueDate)
        return -1;
      if (b.dueDate)
        return 1;
      return 0;
    });
  }
  /**
   * Get tasks for the panel display
   */
  async getTasksForPanel(weekStart) {
    const allTasks = await this.parseAllTasks();
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    const weekEnd = new Date(weekStart);
    weekEnd.setDate(weekEnd.getDate() + 7);
    const todayTasks = [];
    const thisWeekTasks = [];
    const overdueTasks = [];
    for (const task of allTasks) {
      if (task.status !== "todo" && task.status !== "in_progress")
        continue;
      if (task.dueDate) {
        const dueDay = new Date(task.dueDate.getFullYear(), task.dueDate.getMonth(), task.dueDate.getDate());
        if (dueDay < today) {
          overdueTasks.push(task);
        } else if (dueDay.getTime() === today.getTime()) {
          todayTasks.push(task);
        } else if (dueDay >= tomorrow && dueDay < weekEnd) {
          thisWeekTasks.push(task);
        }
      }
    }
    return {
      today: todayTasks,
      thisWeek: thisWeekTasks,
      overdue: overdueTasks
    };
  }
  /**
   * Infer category from task content
   */
  inferCategory(task) {
    const text = (task.title + " " + task.tags.join(" ")).toLowerCase();
    if (/‰ºöËÆÆ|ËÆ®ËÆ∫|sync|meeting|Âë®‰ºö|seminar|oneone/i.test(text)) {
      return "meeting" /* MEETING */;
    }
    if (/ÂÆ∂|Áà∏|Â¶à|gym|‰∏™‰∫∫|ÁîüÊ¥ª|ÊπøÁñπ|ÊåÇÂè∑/i.test(text)) {
      return "personal" /* PERSONAL */;
    }
    if (/Êä•ÈîÄ|Ë°åÊîø|Áî≥ËØ∑|oa/i.test(text)) {
      return "admin" /* ADMIN */;
    }
    if (/‰ºëÊÅØ|Âçà‰ºë|break/i.test(text)) {
      return "rest" /* REST */;
    }
    return "focus" /* FOCUS */;
  }
  /**
   * Check if a file path is a task source
   */
  isTaskSource(filePath) {
    for (const source of this.taskSources) {
      if (source.endsWith("/")) {
        if (filePath.startsWith(source.slice(0, -1))) {
          return true;
        }
      } else {
        if (filePath === source) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Find a task by file path and line number (exact location)
   */
  async findTaskByLocation(sourcePath, lineNumber) {
    const file = this.app.vault.getAbstractFileByPath(sourcePath);
    if (!(file instanceof import_obsidian6.TFile))
      return null;
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    if (lineNumber < 1 || lineNumber > lines.length)
      return null;
    const line = lines[lineNumber - 1];
    return this.parseTaskLine(line, sourcePath, lineNumber);
  }
  /**
   * Find a task by title (fuzzy match)
   */
  async findTaskByTitle(title) {
    const allTasks = await this.parseAllTasks();
    const normalizedTitle = title.toLowerCase().trim();
    let found = allTasks.find((t) => t.title.toLowerCase().trim() === normalizedTitle);
    if (found)
      return found;
    found = allTasks.find(
      (t) => t.title.toLowerCase().includes(normalizedTitle) || normalizedTitle.includes(t.title.toLowerCase())
    );
    return found || null;
  }
  /**
   * Increment the done pomodoro count for a task
   */
  async incrementTaskDone(task) {
    const file = this.app.vault.getAbstractFileByPath(task.sourcePath);
    if (!(file instanceof import_obsidian6.TFile))
      return false;
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    if (task.lineNumber < 1 || task.lineNumber > lines.length)
      return false;
    const lineIndex = task.lineNumber - 1;
    let line = lines[lineIndex];
    const doneMatch = line.match(/\[done::\s*(\d+)\]/);
    if (doneMatch) {
      const currentDone = parseInt(doneMatch[1], 10);
      line = line.replace(/\[done::\s*\d+\]/, `[done:: ${currentDone + 1}]`);
    } else {
      const pomoMatch = line.match(/\[pomo::\s*\d+\]/);
      if (pomoMatch) {
        line = line.replace(/(\[pomo::\s*\d+\])/, `$1 [done:: 1]`);
      } else {
        line = line.trimEnd() + " [done:: 1]";
      }
    }
    lines[lineIndex] = line;
    await this.app.vault.modify(file, lines.join("\n"));
    return true;
  }
};

// src/floatingTimer.ts
var { spawn } = require("child_process");
var path = require("path");
var fs = require("fs");
var os = require("os");
var FloatingTimerWindow = class {
  constructor() {
    this.currentTaskTitle = "";
    this.onComplete = null;
    this.nativeWindowProcess = null;
    this.isNativeWindowActive = false;
  }
  /**
   * Show the floating timer window
   */
  show(taskTitle, onComplete) {
    this.closeNativeWindow();
    this.currentTaskTitle = taskTitle;
    this.onComplete = onComplete || null;
    this.createNativeWindow(taskTitle);
  }
  /**
   * Hide the floating timer window
   */
  hide() {
    this.closeNativeWindow();
  }
  /**
   * Update the timer display
   */
  updateDisplay(minutes, seconds, isRunning, mode = "work") {
    if (this.isNativeWindowActive) {
      this.updateNativeWindow(minutes, seconds, isRunning, mode);
    }
  }
  /**
   * Create a native macOS floating window using Swift
   */
  createNativeWindow(taskTitle) {
    const swiftCode = `
import Cocoa

class TimerWindow: NSWindow {
    var timeLabel: NSTextField!
    var modeLabel: NSTextField!

    init() {
        super.init(
            contentRect: NSRect(x: 0, y: 0, width: 120, height: 50),
            styleMask: [.borderless],
            backing: .buffered,
            defer: false
        )

        // Window properties for floating behavior
        self.level = .floating
        self.backgroundColor = NSColor(white: 0.1, alpha: 0.85)
        self.isOpaque = false
        self.hasShadow = true
        self.isMovableByWindowBackground = true
        self.collectionBehavior = [.canJoinAllSpaces, .fullScreenAuxiliary]

        // Round corners
        self.contentView?.wantsLayer = true
        self.contentView?.layer?.cornerRadius = 10
        self.contentView?.layer?.masksToBounds = true

        // Position in top-right corner
        if let screen = NSScreen.main {
            let screenFrame = screen.visibleFrame
            let x = screenFrame.maxX - 140
            let y = screenFrame.maxY - 70
            self.setFrameOrigin(NSPoint(x: x, y: y))
        }

        setupUI()
    }

    func setupUI() {
        let contentView = self.contentView!

        // Mode emoji
        modeLabel = NSTextField(labelWithString: "\u{1F345}")
        modeLabel.font = NSFont.systemFont(ofSize: 16)
        modeLabel.alignment = .center
        modeLabel.frame = NSRect(x: 8, y: 15, width: 24, height: 20)
        contentView.addSubview(modeLabel)

        // Time label
        timeLabel = NSTextField(labelWithString: "25:00")
        timeLabel.font = NSFont.monospacedDigitSystemFont(ofSize: 24, weight: .semibold)
        timeLabel.textColor = NSColor(red: 0.3, green: 0.8, blue: 0.4, alpha: 1.0)
        timeLabel.alignment = .center
        timeLabel.frame = NSRect(x: 32, y: 12, width: 80, height: 28)
        contentView.addSubview(timeLabel)
    }

    func updateTime(_ time: String, mode: String, isPaused: Bool) {
        timeLabel.stringValue = time
        modeLabel.stringValue = mode == "work" ? "\u{1F345}" : "\u2615"
        timeLabel.textColor = isPaused
            ? NSColor(red: 1.0, green: 0.76, blue: 0.03, alpha: 1.0)
            : NSColor(red: 0.3, green: 0.8, blue: 0.4, alpha: 1.0)
    }
}

class AppDelegate: NSObject, NSApplicationDelegate {
    var window: TimerWindow!
    var inputThread: Thread?

    func applicationDidFinishLaunching(_ notification: Notification) {
        window = TimerWindow()
        window.makeKeyAndOrderFront(nil)

        // Read from stdin for updates
        inputThread = Thread {
            let handle = FileHandle.standardInput
            while true {
                if let data = try? handle.availableData, !data.isEmpty {
                    if let str = String(data: data, encoding: .utf8)?.trimmingCharacters(in: .whitespacesAndNewlines) {
                        if str == "QUIT" {
                            DispatchQueue.main.async {
                                NSApp.terminate(nil)
                            }
                            break
                        }
                        // Format: TIME|MODE|PAUSED (e.g., "24:30|work|false")
                        let parts = str.split(separator: "|")
                        if parts.count >= 3 {
                            let time = String(parts[0])
                            let mode = String(parts[1])
                            let isPaused = parts[2] == "true"
                            DispatchQueue.main.async {
                                self.window.updateTime(time, mode: mode, isPaused: isPaused)
                            }
                        }
                    }
                } else {
                    break
                }
            }
        }
        inputThread?.start()
    }
}

let app = NSApplication.shared
let delegate = AppDelegate()
app.delegate = delegate
app.setActivationPolicy(.accessory)
app.run()
`;
    const scriptPath = path.join(os.tmpdir(), "focus-planner-timer.swift");
    try {
      fs.writeFileSync(scriptPath, swiftCode);
      this.nativeWindowProcess = spawn("swift", [scriptPath], {
        stdio: ["pipe", "pipe", "pipe"]
      });
      this.nativeWindowProcess.on("error", (err) => {
        console.log("[Focus Planner] Native window error:", err);
        this.isNativeWindowActive = false;
      });
      this.nativeWindowProcess.on("exit", () => {
        console.log("[Focus Planner] Native window closed");
        this.isNativeWindowActive = false;
      });
      this.isNativeWindowActive = true;
      console.log("[Focus Planner] Native floating window started");
    } catch (err) {
      console.log("[Focus Planner] Failed to create native window:", err);
      this.isNativeWindowActive = false;
    }
  }
  updateNativeWindow(minutes, seconds, isRunning, mode) {
    if (!this.nativeWindowProcess || !this.nativeWindowProcess.stdin)
      return;
    const timeStr = `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
    const isPaused = !isRunning;
    const message = `${timeStr}|${mode}|${isPaused}
`;
    try {
      this.nativeWindowProcess.stdin.write(message);
    } catch (err) {
      this.isNativeWindowActive = false;
    }
  }
  closeNativeWindow() {
    if (this.nativeWindowProcess) {
      try {
        this.nativeWindowProcess.stdin.write("QUIT\n");
        setTimeout(() => {
          if (this.nativeWindowProcess) {
            this.nativeWindowProcess.kill();
            this.nativeWindowProcess = null;
          }
        }, 500);
      } catch (err) {
        if (this.nativeWindowProcess) {
          this.nativeWindowProcess.kill();
          this.nativeWindowProcess = null;
        }
      }
    }
    this.isNativeWindowActive = false;
  }
  isVisible() {
    return this.isNativeWindowActive;
  }
};

// src/main.ts
var FocusPlannerPlugin = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.syncIntervalId = null;
    this.timerUpdateIntervalId = null;
    this.timerUnsubscribe = null;
  }
  async onload() {
    await this.loadSettings();
    this.dailyNoteParser = new DailyNoteParser(this.app, this.settings);
    this.statsManager = new StatsManager(this.app, this.settings, this.dailyNoteParser);
    this.taskParser = new TaskParser(this.app);
    this.floatingTimer = new FloatingTimerWindow();
    this.feishuApi = new FeishuApi(
      this.settings.feishu,
      async (feishuSettings) => {
        this.settings.feishu = feishuSettings;
        await this.saveSettings();
      }
    );
    this.caldavClient = new CalDavClient(
      this.settings.feishu,
      this.settings.categoryKeywords
    );
    this.registerView(
      VIEW_TYPE_FOCUS_PLANNER,
      (leaf) => {
        const view = new FocusPlannerView(leaf);
        view.onSyncFeishu = () => this.syncFeishuCalendar();
        view.getWeeklyStats = (weekStart) => this.statsManager.getWeeklyStats(weekStart);
        view.onEventClick = (event) => this.handleEventClick(event);
        view.onStartPomodoro = (event) => this.startPomodoroForEvent(event);
        view.onEventUpdate = (event, newStart, newEnd) => this.handleEventUpdate(event, newStart, newEnd);
        view.onEventCreate = (data) => this.handleEventCreate(data);
        view.onEventDelete = (event) => this.handleEventDelete(event);
        view.onWeekChange = (weekStart) => this.getEventsForWeek(weekStart);
        view.onGetTasks = (weekStart) => this.taskParser.getTasksForPanel(weekStart);
        view.onTaskInferCategory = (task) => this.taskParser.inferCategory(task);
        return view;
      }
    );
    this.addRibbonIcon("calendar-clock", "Focus Planner", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-focus-planner",
      name: "Open Focus Planner",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "sync-feishu-calendar",
      name: "Sync Feishu Calendar",
      callback: async () => {
        await this.syncFeishuCalendar();
      }
    });
    this.addSettingTab(new FocusPlannerSettingTab(this.app, this));
    this.startAutoSync();
    this.app.workspace.onLayoutReady(() => {
      this.initializeView();
    });
  }
  onunload() {
    var _a;
    this.stopAutoSync();
    this.stopTimerUpdate();
    (_a = this.floatingTimer) == null ? void 0 : _a.hide();
    if (this.timerUnsubscribe) {
      this.timerUnsubscribe();
      this.timerUnsubscribe = null;
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.dailyNoteParser) {
      this.dailyNoteParser.updateSettings(this.settings);
    }
    if (this.statsManager) {
      this.statsManager.updateSettings(this.settings);
    }
    if (this.feishuApi) {
      this.feishuApi.updateSettings(this.settings.feishu);
    }
    if (this.caldavClient) {
      this.caldavClient.updateSettings(this.settings.feishu, this.settings.categoryKeywords);
    }
    this.startAutoSync();
  }
  // Activate the Focus Planner view
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_FOCUS_PLANNER);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({
          type: VIEW_TYPE_FOCUS_PLANNER,
          active: true
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
      await this.refreshView();
    }
  }
  // Initialize view with current data
  async initializeView() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_FOCUS_PLANNER);
    if (leaves.length > 0) {
      await this.refreshView();
    }
  }
  // Get events for a specific week
  async getEventsForWeek(weekStart) {
    const weekEnd = new Date(weekStart);
    weekEnd.setDate(weekStart.getDate() + 6);
    weekEnd.setHours(23, 59, 59, 999);
    return await this.statsManager.getEventsWithProgress(weekStart, weekEnd);
  }
  // Refresh view with latest events
  async refreshView() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_FOCUS_PLANNER);
    if (leaves.length === 0)
      return;
    const view = leaves[0].view;
    const weekStart = view.getCurrentWeekStart();
    const events = await this.getEventsForWeek(weekStart);
    view.setEvents(events);
  }
  // Sync calendar from Feishu (supports both CalDAV and Open API)
  async syncFeishuCalendar() {
    if (!this.settings.feishu.syncEnabled) {
      new import_obsidian7.Notice("\u98DE\u4E66\u540C\u6B65\u672A\u542F\u7528\uFF0C\u8BF7\u5148\u5728\u8BBE\u7F6E\u4E2D\u542F\u7528");
      return;
    }
    const useCalDav = this.settings.feishu.useCalDav;
    if (useCalDav) {
      if (!this.settings.feishu.caldavUsername || !this.settings.feishu.caldavPassword) {
        new import_obsidian7.Notice("\u8BF7\u5148\u5728\u8BBE\u7F6E\u4E2D\u914D\u7F6E CalDAV \u7528\u6237\u540D\u548C\u5BC6\u7801");
        return;
      }
    } else {
      if (!this.settings.feishu.appId || !this.settings.feishu.appSecret) {
        new import_obsidian7.Notice("\u8BF7\u5148\u5728\u8BBE\u7F6E\u4E2D\u914D\u7F6E\u98DE\u4E66 App ID \u548C App Secret");
        return;
      }
      if (!this.settings.feishu.accessToken) {
        new import_obsidian7.Notice("\u8BF7\u5148\u767B\u5F55\u98DE\u4E66\u8D26\u53F7");
        return;
      }
    }
    try {
      new import_obsidian7.Notice(useCalDav ? "\u6B63\u5728\u901A\u8FC7 CalDAV \u540C\u6B65\u65E5\u5386..." : "\u6B63\u5728\u540C\u6B65\u98DE\u4E66\u65E5\u5386...");
      const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_FOCUS_PLANNER);
      let weekStart;
      if (leaves.length > 0) {
        const view = leaves[0].view;
        weekStart = view.getCurrentWeekStart();
      } else {
        const today = new Date();
        weekStart = new Date(today);
        weekStart.setDate(today.getDate() - today.getDay() + 1);
        weekStart.setHours(0, 0, 0, 0);
      }
      const weekEnd = new Date(weekStart);
      weekEnd.setDate(weekStart.getDate() + 6);
      weekEnd.setHours(23, 59, 59, 999);
      console.log("[Focus Planner] Syncing week:", weekStart.toISOString(), "to", weekEnd.toISOString());
      console.log("[Focus Planner] Using CalDAV:", useCalDav);
      let feishuEvents;
      if (useCalDav) {
        feishuEvents = await this.caldavClient.getEvents(weekStart, weekEnd);
      } else {
        feishuEvents = await this.feishuApi.getEvents(weekStart, weekEnd);
      }
      const eventsByDate = /* @__PURE__ */ new Map();
      for (const event of feishuEvents) {
        const dateKey = event.start.toISOString().split("T")[0];
        if (!eventsByDate.has(dateKey)) {
          eventsByDate.set(dateKey, []);
        }
        eventsByDate.get(dateKey).push(event);
      }
      for (const [dateStr, events] of eventsByDate) {
        const date = new Date(dateStr);
        await this.dailyNoteParser.writeEventsToDailyNote(date, events);
      }
      this.settings.feishu.lastSync = Date.now();
      await this.saveSettings();
      await this.refreshView();
      new import_obsidian7.Notice(`${useCalDav ? "CalDAV" : "\u98DE\u4E66"}\u540C\u6B65\u5B8C\u6210\uFF01\u540C\u6B65\u4E86 ${feishuEvents.length} \u4E2A\u65E5\u7A0B`);
    } catch (error) {
      console.error("Feishu sync error:", error);
      new import_obsidian7.Notice(`\u540C\u6B65\u5931\u8D25: ${error.message}`);
    }
  }
  // Login to Feishu - Step 1: Open OAuth page
  async loginFeishu() {
    if (!this.settings.feishu.appId || !this.settings.feishu.appSecret) {
      new import_obsidian7.Notice("\u8BF7\u5148\u5728\u8BBE\u7F6E\u4E2D\u914D\u7F6E\u98DE\u4E66 App ID \u548C App Secret");
      return;
    }
    const oauthUrl = this.feishuApi.getOAuthUrl("http://localhost:3000/callback");
    new import_obsidian7.Notice(
      "\u6D4F\u89C8\u5668\u5C06\u6253\u5F00\u98DE\u4E66\u6388\u6743\u9875\u9762\u3002\n\u767B\u5F55\u540E\uFF0C\u590D\u5236 URL \u4E2D\u7684 code \u53C2\u6570\uFF0C\n\u7136\u540E\u70B9\u51FB\u300C\u8F93\u5165\u6388\u6743\u7801\u300D\u6309\u94AE\u7C98\u8D34\u3002"
    );
    window.open(oauthUrl);
  }
  // Login to Feishu - Step 2: Handle authorization code
  async handleAuthCode(code) {
    if (!code) {
      new import_obsidian7.Notice("\u6388\u6743\u7801\u4E0D\u80FD\u4E3A\u7A7A");
      return;
    }
    try {
      new import_obsidian7.Notice("\u6B63\u5728\u9A8C\u8BC1\u6388\u6743\u7801...");
      const tokens = await this.feishuApi.getUserAccessToken(code);
      this.settings.feishu.accessToken = tokens.accessToken;
      this.settings.feishu.refreshToken = tokens.refreshToken;
      this.settings.feishu.tokenExpiry = Date.now() + tokens.expiresIn * 1e3;
      await this.saveSettings();
      this.startAutoSync();
      new import_obsidian7.Notice("\u98DE\u4E66\u767B\u5F55\u6210\u529F\uFF01");
    } catch (error) {
      console.error("Feishu auth error:", error);
      new import_obsidian7.Notice(`\u767B\u5F55\u5931\u8D25: ${error.message}`);
    }
  }
  // Handle event click in calendar
  handleEventClick(event) {
    if (event.filePath) {
      const file = this.app.vault.getAbstractFileByPath(event.filePath);
      if (file) {
        this.app.workspace.openLinkText("", event.filePath);
      }
    }
  }
  // Start pomodoro timer for an event
  async startPomodoroForEvent(event) {
    var _a, _b;
    const pomodoroPlugin = (_b = (_a = this.app.plugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["pomodoro-timer"];
    if (pomodoroPlugin) {
      this.app.commands.executeCommandById("pomodoro-timer:toggle-timer");
      this.floatingTimer.show(event.title, () => {
        new import_obsidian7.Notice(`\u{1F345} \u756A\u8304\u949F\u5B8C\u6210: ${event.title}`);
      });
      this.startTimerUpdate();
      let taskUpdated = false;
      let newDone = 0;
      let totalPomos = 0;
      if (event.taskSourcePath && event.taskLineNumber) {
        const task = await this.taskParser.findTaskByLocation(event.taskSourcePath, event.taskLineNumber);
        if (task) {
          taskUpdated = await this.taskParser.incrementTaskDone(task);
          newDone = task.pomodorosDone + 1;
          totalPomos = task.pomodoros;
        }
      }
      if (!taskUpdated) {
        const task = await this.taskParser.findTaskByTitle(event.title);
        if (task) {
          taskUpdated = await this.taskParser.incrementTaskDone(task);
          newDone = task.pomodorosDone + 1;
          totalPomos = task.pomodoros;
        }
      }
      if (taskUpdated) {
        const total = totalPomos > 0 ? `/${totalPomos}` : "";
        new import_obsidian7.Notice(`\u{1F345} \u5F00\u59CB\u756A\u8304\u949F: ${event.title}
\u{1F4DD} \u5DF2\u5B8C\u6210: ${newDone}${total}\u{1F345}`);
      } else {
        new import_obsidian7.Notice(`\u{1F345} \u5F00\u59CB\u756A\u8304\u949F: ${event.title}`);
      }
    } else {
      new import_obsidian7.Notice("\u8BF7\u5148\u5B89\u88C5\u5E76\u542F\u7528 Pomodoro Timer \u63D2\u4EF6");
    }
  }
  // Handle event deletion (context menu)
  async handleEventDelete(event) {
    if (event.source !== "local") {
      throw new Error("\u53EA\u80FD\u5220\u9664\u672C\u5730\u65E5\u62A5\u4E2D\u7684\u4E8B\u4EF6");
    }
    const date = new Date(event.start);
    date.setHours(0, 0, 0, 0);
    await this.dailyNoteParser.removeEventFromDailyNote(date, event);
    await this.refreshView();
  }
  // Handle event creation (double-click on calendar or drag from task panel)
  async handleEventCreate(data) {
    const date = new Date(data.start);
    date.setHours(0, 0, 0, 0);
    const newEvent = {
      id: `local-new-${Date.now()}`,
      title: data.title,
      start: data.start,
      end: data.end,
      category: data.category,
      source: "local",
      // Save task link for pomodoro tracking
      taskSourcePath: data.taskSourcePath,
      taskLineNumber: data.taskLineNumber
    };
    await this.dailyNoteParser.addEventToDailyNote(date, newEvent);
    await this.refreshView();
  }
  // Handle event update (drag and drop)
  async handleEventUpdate(event, newStart, newEnd) {
    if (event.source !== "local" || !event.filePath) {
      throw new Error("\u53EA\u80FD\u79FB\u52A8\u672C\u5730\u65E5\u62A5\u4E2D\u7684\u4E8B\u4EF6");
    }
    const oldDate = new Date(event.start);
    oldDate.setHours(0, 0, 0, 0);
    const newDate = new Date(newStart);
    newDate.setHours(0, 0, 0, 0);
    const dateChanged = oldDate.getTime() !== newDate.getTime();
    if (dateChanged) {
      await this.dailyNoteParser.removeEventFromDailyNote(oldDate, event);
      await this.dailyNoteParser.addEventToDailyNote(newDate, {
        ...event,
        start: newStart,
        end: newEnd
      });
    } else {
      await this.dailyNoteParser.updateEventInDailyNote(event, newStart, newEnd);
    }
    await this.refreshView();
  }
  // Start auto-sync interval
  startAutoSync() {
    this.stopAutoSync();
    const useCalDav = this.settings.feishu.useCalDav;
    const hasCredentials = useCalDav ? this.settings.feishu.caldavUsername && this.settings.feishu.caldavPassword : this.settings.feishu.accessToken;
    if (this.settings.feishu.syncEnabled && hasCredentials && this.settings.feishu.syncInterval > 0) {
      const intervalMs = this.settings.feishu.syncInterval * 60 * 1e3;
      this.syncIntervalId = window.setInterval(async () => {
        await this.syncFeishuCalendar();
      }, intervalMs);
    }
  }
  // Stop auto-sync interval
  stopAutoSync() {
    if (this.syncIntervalId !== null) {
      window.clearInterval(this.syncIntervalId);
      this.syncIntervalId = null;
    }
  }
  // Start subscribing to pomodoro timer state
  startTimerUpdate() {
    var _a, _b;
    this.stopTimerUpdate();
    const pomodoroPlugin = (_b = (_a = this.app.plugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["pomodoro-timer"];
    if (!pomodoroPlugin) {
      console.log("[Focus Planner] Pomodoro plugin not found");
      return;
    }
    const timerStore = pomodoroPlugin.timer;
    if (timerStore && typeof timerStore.subscribe === "function") {
      console.log("[Focus Planner] Subscribing to pomodoro timer store");
      this.timerUnsubscribe = timerStore.subscribe((state) => {
        if (!state)
          return;
        const running = state.running || false;
        const remained = state.remained || { millis: 0 };
        const mode = state.mode || "work";
        const totalSeconds = Math.ceil(remained.millis / 1e3);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        this.floatingTimer.updateDisplay(minutes, seconds, running, mode);
        if (state.finished && !running) {
          setTimeout(() => {
            if (!this.timerUpdateIntervalId && this.floatingTimer.isVisible()) {
              this.floatingTimer.hide();
              this.stopTimerUpdate();
            }
          }, 3e3);
        }
      });
    } else {
      console.log("[Focus Planner] Timer store not found, using polling fallback");
      this.timerUpdateIntervalId = window.setInterval(() => {
        this.updateFloatingTimerPolling();
      }, 500);
    }
  }
  // Stop timer update interval and unsubscribe
  stopTimerUpdate() {
    if (this.timerUnsubscribe) {
      this.timerUnsubscribe();
      this.timerUnsubscribe = null;
    }
    if (this.timerUpdateIntervalId !== null) {
      window.clearInterval(this.timerUpdateIntervalId);
      this.timerUpdateIntervalId = null;
    }
  }
  // Fallback: polling update for floating timer
  updateFloatingTimerPolling() {
    var _a, _b;
    const pomodoroPlugin = (_b = (_a = this.app.plugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["pomodoro-timer"];
    if (!pomodoroPlugin) {
      this.stopTimerUpdate();
      this.floatingTimer.hide();
      return;
    }
    const timerStore = pomodoroPlugin.timer;
    if (timerStore) {
      let state = null;
      if (typeof timerStore.get === "function") {
        state = timerStore.get();
      }
      if (state) {
        const running = state.running || false;
        const remained = state.remained || { millis: 0 };
        const mode = state.mode || "work";
        const totalSeconds = Math.ceil(remained.millis / 1e3);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        this.floatingTimer.updateDisplay(minutes, seconds, running, mode);
      }
    }
  }
};
